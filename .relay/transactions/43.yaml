uuid: 4f1a2b3c-5d6e-7f8a-9b0c-1d2e3f4a5b6d
projectId: quackgraph
createdAt: '2025-12-02T14:02:28.913Z'
gitCommitMsg: >-
  feat(api): add recursive traversals and merge upserts

  Enables variable-length path queries (e.g. `recursive('KNOWS', {min:1,
  max:5})`) via the JS API. Adds `mergeNode` for idempotent node ingestion
  (Match-or-Create) logic backed by DuckDB transactions.
promptSummary: >-
  Implemented the Fluent API for Recursive Traversals and Declarative Mutations.
  Updated `QueryBuilder` to support `.recursive()` utilizing the new Native BFS
  engine. Added `mergeNode` to `SchemaManager` implementing SCD Type 2 Upsert
  logic with idempotency.
reasoning:
  - >-
    To upgrade the TypeScript Fluent API with Recursive Traversals and
    Declarative Mutations, I will modify `query.ts` to support the new
    `recursive` step in the AST, `schema.ts` to implement the `MERGE` logic via
    transactions, and `graph.ts` to expose these features publicly.
  - '### 1. Update Query Builder (Recursive Steps)'
  - '### 2. Implement MERGE in Schema Manager'
  - '### 3. Expose Mutations in Graph API'
operations:
  - type: write
    path: packages/quack-graph/src/query.ts
    content: >
      --- packages/quack-graph/src/query.ts

      +++ packages/quack-graph/src/query.ts

      @@ -3,4 +3,6 @@
       type TraversalStep = {
      -  type: 'out' | 'in';

      +  type: 'out' | 'in' | 'recursive';
         edge: string;
      +  direction?: 'out' | 'in';

      +  bounds?: { min: number; max: number };
       };
      @@ -64,2 +66,19 @@
       
      +  /**

      +   * Traverses the graph recursively (BFS) with depth bounds.

      +   * Useful for variable length paths like `(a)-[:KNOWS*1..5]->(b)`.

      +   * @param edgeType The edge label to follow.

      +   * @param options min/max depth (default: 1..5).

      +   * @param direction 'out' (default) or 'in'.

      +   */

      +  recursive(edgeType: string, options: { min?: number; max?: number } =
      {}, direction: 'out' | 'in' = 'out'): this {

      +    this.traversals.push({

      +      type: 'recursive',

      +      edge: edgeType,

      +      direction,

      +      bounds: {

      +        min: options.min ?? 1,

      +        max: options.max ?? 5,

      +      }

      +    });

      +    return this;

      +  }

      +
         /**
      @@ -160,5 +179,16 @@
           for (const step of this.traversals) {
             if (currentIds.length === 0) break;
      -      // step.type is 'out' | 'in'

      -      // native.traverse(ids, edgeType, direction)

      -      currentIds = this.graph.native.traverse(currentIds, step.edge,
      step.type);

      +      

      +      if (step.type === 'recursive') {

      +        currentIds = this.graph.native.traverseRecursive(

      +          currentIds,

      +          step.edge,

      +          step.direction || 'out',

      +          step.bounds?.min,

      +          step.bounds?.max

      +        );

      +      } else {

      +        // step.type is 'out' | 'in'

      +        currentIds = this.graph.native.traverse(currentIds, step.edge,
      step.type as 'out' | 'in');

      +      }
           }
    patchStrategy: standard-diff
  - type: write
    path: packages/quack-graph/src/schema.ts
    content: >
      --- packages/quack-graph/src/schema.ts

      +++ packages/quack-graph/src/schema.ts

      @@ -118,2 +118,52 @@
         }
      +

      +  /**

      +   * Declarative Merge (Upsert).

      +   * Finds a node by `matchProps` and `label`.

      +   * If found: Updates properties with `setProps`.

      +   * If not found: Creates new node with `matchProps` + `setProps`.

      +   * Returns the node ID.

      +   */

      +  async mergeNode(label: string, matchProps: Record<string, any>,
      setProps: Record<string, any>): Promise<string> {

      +    // 1. Build Search Query

      +    const matchKeys = Object.keys(matchProps);

      +    const conditions = [`valid_to IS NULL`, `list_contains(labels, ?)`];

      +    // biome-ignore lint/suspicious/noExplicitAny: Params array

      +    const params: any[] = [label];

      +    

      +    for (const key of matchKeys) {

      +      if (key === 'id') {

      +        conditions.push(`id = ?`);

      +        params.push(matchProps[key]);

      +      } else {

      +        conditions.push(`json_extract(properties, '$.${key}') =
      ?::JSON`);

      +        params.push(JSON.stringify(matchProps[key]));

      +      }

      +    }

      +

      +    const searchSql = `SELECT id, labels, properties FROM nodes WHERE
      ${conditions.join(' AND ')} LIMIT 1`;

      +

      +    return await this.db.transaction(async (tx) => {

      +      const rows = await tx.query(searchSql, params);

      +      let id: string;

      +      let finalProps: Record<string, any>;

      +      let finalLabels: string[];

      +

      +      if (rows.length > 0) {

      +        // Update Existing

      +        const row = rows[0];

      +        id = row.id;

      +        const currentProps = typeof row.properties === 'string' ?
      JSON.parse(row.properties) : row.properties;

      +        finalProps = { ...currentProps, ...setProps };

      +        finalLabels = row.labels; // Preserve existing labels

      +

      +        // Close old version

      +        await tx.execute(`UPDATE nodes SET valid_to = current_timestamp
      WHERE id = ? AND valid_to IS NULL`, [id]);

      +      } else {

      +        // Insert New

      +        id = matchProps['id'] || crypto.randomUUID();

      +        finalProps = { ...matchProps, ...setProps };

      +        finalLabels = [label];

      +      }

      +

      +      // Insert new version (for both Update and Create cases)

      +      await tx.execute(`

      +        INSERT INTO nodes (row_id, id, labels, properties, valid_from,
      valid_to) 

      +        VALUES (nextval('seq_node_id'), ?, ?::JSON::TEXT[], ?::JSON,
      current_timestamp, NULL)

      +      `, [id, JSON.stringify(finalLabels), JSON.stringify(finalProps)]);

      +

      +      return id;

      +    });

      +  }
       }
    patchStrategy: standard-diff
  - type: write
    path: packages/quack-graph/src/graph.ts
    content: >
      --- packages/quack-graph/src/graph.ts

      +++ packages/quack-graph/src/graph.ts

      @@ -131,2 +131,14 @@
       
      +  /**

      +   * Upsert a node.

      +   * @param label Primary label to match.

      +   * @param matchProps Properties to match against (e.g. { email: '...'
      }).

      +   * @param setProps Properties to set/update if found or created.

      +   */

      +  async mergeNode(label: string, matchProps: Record<string, any>,
      setProps: Record<string, any> = {}) {

      +    const id = await this.schema.mergeNode(label, matchProps, setProps);

      +    // Update cache

      +    this.native.addNode(id);

      +    return id;

      +  }

      +
         // --- Optimization & Maintenance ---
    patchStrategy: standard-diff
snapshot:
  packages/quack-graph/src/schema.ts: |-
    import type { DuckDBManager, DbExecutor } from './db';

    const NODES_TABLE = `
    CREATE TABLE IF NOT EXISTS nodes (
        row_id UBIGINT PRIMARY KEY, -- Simple auto-increment equivalent logic handled by sequence
        id TEXT NOT NULL,
        labels TEXT[],
        properties JSON,
        embedding FLOAT[], -- Vector embedding
        valid_from TIMESTAMPTZ DEFAULT current_timestamp,
        valid_to TIMESTAMPTZ DEFAULT NULL
    );
    CREATE SEQUENCE IF NOT EXISTS seq_node_id;
    `;

    const EDGES_TABLE = `
    CREATE TABLE IF NOT EXISTS edges (
        source TEXT NOT NULL,
        target TEXT NOT NULL,
        type TEXT NOT NULL,
        properties JSON,
        valid_from TIMESTAMPTZ DEFAULT current_timestamp,
        valid_to TIMESTAMPTZ DEFAULT NULL
    );
    `;

    export class SchemaManager {
      constructor(private db: DuckDBManager) {}

      async ensureSchema() {
        await this.db.execute(NODES_TABLE);
        await this.db.execute(EDGES_TABLE);
      }

      // biome-ignore lint/suspicious/noExplicitAny: generic properties
      async writeNode(id: string, labels: string[], properties: Record<string, any> = {}) {
        await this.db.transaction(async (tx: DbExecutor) => {
          // 1. Close existing record (SCD Type 2)
          await tx.execute(
            `UPDATE nodes SET valid_to = current_timestamp WHERE id = ? AND valid_to IS NULL`,
            [id]
          );
          // 2. Insert new version
          await tx.execute(`
            INSERT INTO nodes (row_id, id, labels, properties, valid_from, valid_to) 
            VALUES (nextval('seq_node_id'), ?, ?::JSON::TEXT[], ?::JSON, current_timestamp, NULL)
          `, [id, JSON.stringify(labels), JSON.stringify(properties)]);
        });
      }

      // biome-ignore lint/suspicious/noExplicitAny: generic properties
      async writeEdge(source: string, target: string, type: string, properties: Record<string, any> = {}) {
        await this.db.transaction(async (tx: DbExecutor) => {
          // 1. Close existing edge
          await tx.execute(
            `UPDATE edges SET valid_to = current_timestamp WHERE source = ? AND target = ? AND type = ? AND valid_to IS NULL`,
            [source, target, type]
          );
          // 2. Insert new version
          await tx.execute(`
            INSERT INTO edges (source, target, type, properties, valid_from, valid_to) 
            VALUES (?, ?, ?, ?::JSON, current_timestamp, NULL)
          `, [source, target, type, JSON.stringify(properties)]);
        });
      }

      async deleteNode(id: string) {
        // Soft Delete: Close the validity period
        await this.db.transaction(async (tx: DbExecutor) => {
          await tx.execute(
            `UPDATE nodes SET valid_to = current_timestamp WHERE id = ? AND valid_to IS NULL`,
            [id]
          );
        });
      }

      async deleteEdge(source: string, target: string, type: string) {
        // Soft Delete: Close the validity period
        await this.db.transaction(async (tx: DbExecutor) => {
          await tx.execute(
            `UPDATE edges SET valid_to = current_timestamp WHERE source = ? AND target = ? AND type = ? AND valid_to IS NULL`,
            [source, target, type]
          );
        });
      }

      /**
       * Promotes a JSON property to a native column for faster filtering.
       * This creates a column on the `nodes` table and backfills it from the `properties` JSON blob.
       * 
       * @param label The node label to target (e.g., 'User'). Only nodes with this label will be updated.
       * @param property The property key to promote (e.g., 'age').
       * @param type The DuckDB SQL type (e.g., 'INTEGER', 'VARCHAR').
       */
      async promoteNodeProperty(label: string, property: string, type: string) {
        // Sanitize inputs to prevent basic SQL injection (rudimentary check)
        if (!/^[a-zA-Z0-9_]+$/.test(property)) throw new Error(`Invalid property name: '${property}'. Must be alphanumeric + underscore.`);
        // Type check is looser to allow various SQL types, but strictly alphanumeric + spaces/parens usually safe enough for now
        if (!/^[a-zA-Z0-9_() ]+$/.test(type)) throw new Error(`Invalid SQL type: '${type}'.`);
        // Sanitize label just in case, though it is used as a parameter usually, here we might need dynamic check if we were using it in table names, but we use it in list_contains param.
        
        // 1. Add Column (Idempotent)
        try {
          // Note: DuckDB 0.9+ supports ADD COLUMN IF NOT EXISTS
          await this.db.execute(`ALTER TABLE nodes ADD COLUMN IF NOT EXISTS ${property} ${type}`);
        } catch (_e) {
          // Fallback or ignore if column exists
        }

        // 2. Backfill Data
        // We use list_contains to only update relevant nodes
        const sql = `
          UPDATE nodes 
          SET ${property} = CAST(json_extract(properties, '$.${property}') AS ${type})
          WHERE list_contains(labels, ?)
        `;
        await this.db.execute(sql, [label]);
      }
    }
  packages/quack-graph/src/graph.ts: |-
    import { NativeGraph } from '@quackgraph/native';
    import { DuckDBManager } from './db';
    import { SchemaManager } from './schema';
    import { QueryBuilder } from './query';

    export class QuackGraph {
      db: DuckDBManager;
      schema: SchemaManager;
      native: NativeGraph;
      
      capabilities = {
        vss: false
      };

      // Context for the current instance (Time Travel)
      context: {
        asOf?: Date;
        topologySnapshot?: string;
      } = {};

      constructor(path: string = ':memory:', options: { asOf?: Date, topologySnapshot?: string } = {}) {
        this.db = new DuckDBManager(path);
        this.schema = new SchemaManager(this.db);
        this.native = new NativeGraph();
        this.context.asOf = options.asOf;
        this.context.topologySnapshot = options.topologySnapshot;
      }

      async init() {
        await this.db.init();
        
        // Load Extensions
        try {
          await this.db.execute("INSTALL vss; LOAD vss;");
          this.capabilities.vss = true;
        } catch (e) {
          console.warn("QuackGraph: Failed to load 'vss' extension. Vector search will be disabled.", e);
        }
        
        await this.schema.ensureSchema();
        
        // If we are in time-travel mode, we might skip hydration or hydrate a snapshot (Advanced).
        // For V1, we always hydrate "Current Active" topology.

        // Check for Topology Snapshot
        if (this.context.topologySnapshot) {
          try {
            // Try loading from disk
            this.native.loadSnapshot(this.context.topologySnapshot);
            // If successful, skip hydration
            return;
          } catch (e) {
            console.warn(`QuackGraph: Failed to load snapshot '${this.context.topologySnapshot}'. Falling back to full hydration.`, e);
          }
        }

        try {
          await this.hydrate();
        } catch (e) {
          console.error("Failed to hydrate graph topology from disk:", e);
          // We don't throw here to allow partial functionality (metadata queries) if needed,
          // but usually this is fatal for graph operations.
          throw e;
        }
      }

      /**
       * Hydrates the in-memory Rust graph from the persistent DuckDB storage.
       * This is critical for the "Split-Brain" architecture.
       */
      async hydrate() {
        // Zero-Copy Arrow IPC
        // 'valid_to IS NULL' ensures we only load currently active edges.
        try {
          const ipcBuffer = await this.db.queryArrow(
            "SELECT source, target, type FROM edges WHERE valid_to IS NULL"
          );
        
          if (ipcBuffer && ipcBuffer.length > 0) {
             // Napi-rs expects a Buffer or equivalent
             // Buffer.from is zero-copy in Node for Uint8Array usually, or cheap copy
             // We cast to any to satisfy the generated TS definitions which might expect Buffer
             const bufferForNapi = Buffer.isBuffer(ipcBuffer) 
                ? ipcBuffer 
                : Buffer.from(ipcBuffer);
                
             this.native.loadArrowIpc(bufferForNapi);

             // Reclaim memory after burst hydration
             this.native.compact();
          }
        // biome-ignore lint/suspicious/noExplicitAny: error handling
        } catch (e: any) {
          throw new Error(`Hydration Error: ${e.message}`);
        }
      }

      asOf(date: Date): QuackGraph {
        // Return a shallow copy with new context
        const g = new QuackGraph(this.db.path, { asOf: date });
        // Share the same DB connection and Native index (assuming topology is shared/latest)
        g.db = this.db;
        g.schema = this.schema;
        g.native = this.native;
        g.capabilities = { ...this.capabilities };
        return g;
      }

      // --- Write Operations (Write-Through) ---

      // biome-ignore lint/suspicious/noExplicitAny: generic properties
      async addNode(id: string, labels: string[], props: Record<string, any> = {}) {
        // 1. Write to Disk (Source of Truth)
        await this.schema.writeNode(id, labels, props);
        // 2. Write to RAM (Cache)
        this.native.addNode(id);
      }

      // biome-ignore lint/suspicious/noExplicitAny: generic properties
      async addEdge(source: string, target: string, type: string, props: Record<string, any> = {}) {
        // 1. Write to Disk
        await this.schema.writeEdge(source, target, type, props);
        // 2. Write to RAM
        this.native.addEdge(source, target, type);
      }

      async deleteNode(id: string) {
        // 1. Write to Disk (Soft Delete)
        await this.schema.deleteNode(id);
        // 2. Write to RAM (Tombstone)
        this.native.removeNode(id);
      }

      async deleteEdge(source: string, target: string, type: string) {
        // 1. Write to Disk (Soft Delete)
        await this.schema.deleteEdge(source, target, type);
        // 2. Write to RAM (Remove)
        this.native.removeEdge(source, target, type);
      }

      // --- Optimization & Maintenance ---

      get optimize() {
        return {
          promoteProperty: async (label: string, property: string, type: string) => {
            await this.schema.promoteNodeProperty(label, property, type);
          },
          saveTopologySnapshot: (path: string) => {
            this.native.saveSnapshot(path);
          }
        };
      }

      // --- Read Operations ---

      match(labels: string[]): QueryBuilder {
        return new QueryBuilder(this, labels);
      }
    }
  packages/quack-graph/src/query.ts: |-
    import type { QuackGraph } from './graph';

    type TraversalStep = {
      type: 'out' | 'in';
      edge: string;
    };

    export class QueryBuilder {
      private graph: QuackGraph;
      private startLabels: string[];
      private endLabels: string[] = [];

      // Bottom Bun Filters (Initial selection)
      // biome-ignore lint/suspicious/noExplicitAny: Generic filter criteria
      private initialFilters: Record<string, any> = {};
      private vectorSearch: { vector: number[]; limit: number } | null = null;

      // The Meat (Traversal)
      private traversals: TraversalStep[] = [];

      // Top Bun Filters (Final selection)
      // biome-ignore lint/suspicious/noExplicitAny: Generic filter criteria
      private terminalFilters: Record<string, any> = {};

      constructor(graph: QuackGraph, labels: string[]) {
        this.graph = graph;
        this.startLabels = labels;
      }

      /**
       * Filter nodes by properties.
       * If called before traversal, applies to Start Nodes.
       * If called after traversal, applies to End Nodes.
       */
      // biome-ignore lint/suspicious/noExplicitAny: Generic filter criteria
      where(criteria: Record<string, any>): this {
        if (this.traversals.length === 0) {
          this.initialFilters = { ...this.initialFilters, ...criteria };
        } else {
          this.terminalFilters = { ...this.terminalFilters, ...criteria };
        }
        return this;
      }

      /**
       * Perform a Vector Similarity Search (HNSW).
       * This effectively sorts the start nodes by distance to the query vector.
       */
      nearText(vector: number[], options: { limit?: number } = {}): this {
        this.vectorSearch = { 
          vector, 
          limit: options.limit || 10 
        };
        return this;
      }

      out(edgeType: string): this {
        this.traversals.push({ type: 'out', edge: edgeType });
        return this;
      }

      in(edgeType: string): this {
        this.traversals.push({ type: 'in', edge: edgeType });
        return this;
      }

      /**
       * Filter the nodes at the end of the traversal by label.
       */
      node(labels: string[]): this {
        this.endLabels = labels;
        return this;
      }

      /**
       * Helper to construct the temporal validity clause
       */
      private getTemporalClause(tableAlias: string = ''): string {
        const prefix = tableAlias ? `${tableAlias}.` : '';
        if (this.graph.context.asOf) {
          // Time Travel: valid_from <= T AND (valid_to > T OR valid_to IS NULL)
          // Interpolate strict ISO string
          const iso = this.graph.context.asOf.toISOString();
          // DuckDB TIMESTAMP comparison works with ISO strings
          return `(${prefix}valid_from <= '${iso}' AND (${prefix}valid_to > '${iso}' OR ${prefix}valid_to IS NULL))`;
        }
        // Default: Current valid records (valid_to is NULL)
        return `${prefix}valid_to IS NULL`;
      }

      // biome-ignore lint/suspicious/noExplicitAny: Generic result mapper
      async select<T = any>(mapper?: (node: any) => T): Promise<T[]> {
        // --- Step 1: DuckDB Filter (Bottom Bun) ---
        // Objective: Get a list of "Active" Node IDs to feed into the graph.

        let query = `SELECT id FROM nodes`;
        // biome-ignore lint/suspicious/noExplicitAny: SQL parameters
        const params: any[] = [];
        const conditions: string[] = [];

        // 1.a Temporal Filter
        conditions.push(this.getTemporalClause());

        // 1.b Label Filter
        if (this.startLabels.length > 0) {
          // Check if ANY of the labels match. For V1 we check the first one or intersection.
          conditions.push(`list_contains(labels, ?)`);
          params.push(this.startLabels[0]);
        }

        // 1.c Property Filter
        for (const [key, value] of Object.entries(this.initialFilters)) {
          if (key === 'id') {
            conditions.push(`id = ?`);
            params.push(value);
          } else {
            conditions.push(`json_extract(properties, '$.${key}') = ?::JSON`);
            params.push(JSON.stringify(value));
          }
        }

        // 1.d Vector Search (Order By Distance)
        let orderBy = '';
        let limit = '';
        if (this.vectorSearch) {
          // Requires: array_distance(embedding, [1,2,3])
          // DuckDB VSS extension syntax
          const vectorStr = `[${this.vectorSearch.vector.join(',')}]`; // Inline vector for V1
          orderBy = `ORDER BY array_distance(embedding, ${vectorStr}::FLOAT[${this.vectorSearch.vector.length}])`;
          limit = `LIMIT ${this.vectorSearch.limit}`;
        }

        if (conditions.length > 0) {
          query += ` WHERE ${conditions.join(' AND ')}`;
        }

        query += ` ${orderBy} ${limit}`;

        const startRows = await this.graph.db.query(query, params);
        let currentIds: string[] = startRows.map(row => row.id);

        if (currentIds.length === 0) return [];

        // --- Step 2: Rust Traversal (The Meat) ---
        // Note: Rust Graph Index is currently "Latest Topology Only". 
        // Time Travel on topology requires checking edge validity during traversal (V2).
        // For V1, we accept that traversal is instant/current, but properties are historical.

        for (const step of this.traversals) {
          if (currentIds.length === 0) break;
          // step.type is 'out' | 'in'
          // native.traverse(ids, edgeType, direction)
          currentIds = this.graph.native.traverse(currentIds, step.edge, step.type);
        }

        // Optimization: If traversal resulted in no nodes, stop early.
        if (currentIds.length === 0) return [];

        // --- Step 3: DuckDB Hydration (Top Bun) ---
        // Objective: Fetch full properties for the resulting IDs, applying terminal filters.

        const finalConditions: string[] = [];
        // biome-ignore lint/suspicious/noExplicitAny: SQL parameters
        const finalParams: any[] = [];

        // 3.0 Label Filter (for End Nodes)
        if (this.endLabels.length > 0) {
          finalConditions.push(`list_contains(labels, ?)`);
          finalParams.push(this.endLabels[0]);
        }

        // 3.a IDs match
        // We can't use parameters for IN clause effectively with dynamic length in all drivers.
        // Constructing placeholders.
        const placeholders = currentIds.map(() => '?').join(',');
        finalConditions.push(`id IN (${placeholders})`);
        finalParams.push(...currentIds);

        // 3.b Temporal Validity
        finalConditions.push(this.getTemporalClause());

        // 3.c Terminal Property Filters
        for (const [key, value] of Object.entries(this.terminalFilters)) {
          if (key === 'id') {
            finalConditions.push(`id = ?`);
            finalParams.push(value);
          } else {
            finalConditions.push(`json_extract(properties, '$.${key}') = ?::JSON`);
            finalParams.push(JSON.stringify(value));
          }
        }

        const finalSql = `SELECT * FROM nodes WHERE ${finalConditions.join(' AND ')}`;
        const results = await this.graph.db.query(finalSql, finalParams);

        return results.map(r => {
          let props = r.properties;
          if (typeof props === 'string') {
            try { props = JSON.parse(props); } catch {}
          }
          const node = {
            id: r.id,
            labels: r.labels,
            ...props
          };
          return mapper ? mapper(node) : node;
        });
      }
    }
approved: true
linesAdded: 108
linesRemoved: 4
linesDifference: 112
gitCommittedAt: null
status: committed
id: 43
