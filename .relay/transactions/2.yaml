uuid: 4f12a3b9-1234-4567-8901-abcdef123456
projectId: quackgraph
createdAt: '2025-12-02T05:36:53.103Z'
gitCommitMsg: >-
  feat(native): implement napi-rs bridge

  Scaffolds the `packages/native` directory and implements the `NativeGraph`
  class. This allows TypeScript to instantiate the Rust graph index, add
  nodes/edges, and perform traversals via N-API.
promptSummary: >-
  Executed Part 2. Created the `packages/native` workspace with Napi-rs
  configuration. Implemented `NativeGraph` struct to bridge JS calls to the Rust
  `GraphIndex`. Added a helper `node_count` method to the core topology.
reasoning:
  - >-
    Step 2 of the plan focuses on building the **Native Bridge** using
    `napi-rs`. This layer acts as the glue between the TypeScript runtime
    (Bun/Node) and our Rust `quack_core` logic.
  - >-
    I will scaffold the `packages/native` directory with the necessary NAPI
    configuration and implement the `NativeGraph` class that wraps our pure Rust
    `GraphIndex`.
  - '### 1. Scaffold Native Package (`package.json`)'
  - >-
    We need a `package.json` specific to this package to handle the NAPI build
    scripts and dependencies.
  - '### 2. Configure Rust Crate (`Cargo.toml`)'
  - >-
    We configure this crate as a `cdylib` (C-Dynamic Library) so it can be
    loaded by Node.js. We reference `quack_core` from the local workspace.
  - '### 3. Napi Build Script (`build.rs`)'
  - Standard boilerplate to link NAPI extensions.
  - '### 4. Implement the Bridge (`src/lib.rs`)'
  - Here we expose the Rust logic to JavaScript.
  - '*   We wrap `quack_core::GraphIndex` inside a struct marked with `#[napi]`.'
  - '*   We expose methods like `addNode`, `addEdge`, and `traverse`.'
  - >-
    *   Note: `napi-rs` automatically handles the conversion between
    `Vec<String>` (Rust) and `string[]` (JS).
  - >-
    **Correction:** I realized I added `node_count` usage in `lib.rs` but didn't
    explicitly add a public `node_count` method to `quack_core::GraphIndex` in
    Part 1 (I added `len()` to `Interner`, but not a proxy on `GraphIndex`). I
    should add a quick patch to `quack_core` to expose this, or use the interner
    directly. To keep it clean, I'll update `quack_core` to expose `node_count`.
operations:
  - type: write
    path: packages/native/package.json
    content: |-
      {
        "name": "@quackgraph/native",
        "version": "0.0.1",
        "main": "index.js",
        "types": "index.d.ts",
        "napi": {
          "name": "quack-native",
          "triples": {
            "defaults": true,
            "additional": [
              "x86_64-unknown-linux-musl",
              "aarch64-unknown-linux-gnu",
              "i686-pc-windows-msvc",
              "armv7-unknown-linux-gnueabihf",
              "aarch64-apple-darwin",
              "aarch64-linux-android",
              "x86_64-unknown-freebsd",
              "aarch64-unknown-linux-musl",
              "aarch64-pc-windows-msvc",
              "armv7-linux-androideabi"
            ]
          }
        },
        "scripts": {
          "build": "napi build --platform --release",
          "build:debug": "napi build --platform",
          "artifacts": "napi artifacts",
          "test": "node --test"
        },
        "devDependencies": {
          "@napi-rs/cli": "^2.18.0"
        },
        "engines": {
          "node": ">= 10"
        }
      }
    patchStrategy: replace
  - type: write
    path: packages/native/Cargo.toml
    content: >-
      [package]

      edition = "2021"

      name = "quack_native"

      version = "0.0.1"


      [lib]

      crate-type = ["cdylib"]


      [dependencies]

      # Napi dependencies for bridging

      napi = { version = "2.12.2", default-features = false, features =
      ["napi4"] }

      napi-derive = "2.12.2"


      # Our Core Logic

      quack_core = { path = "../../crates/quack_core" }


      [build-dependencies]

      napi-build = "2.0.1"


      [profile.release]

      lto = true
    patchStrategy: replace
  - type: write
    path: packages/native/build.rs
    content: |-
      extern crate napi_build;

      fn main() {
        napi_build::setup();
      }
    patchStrategy: replace
  - type: write
    path: packages/native/src/lib.rs
    content: |-
      #![deny(clippy::all)]

      use napi::bindgen_prelude::*;
      use napi_derive::napi;
      use quack_core::GraphIndex;

      #[napi]
      pub struct NativeGraph {
          inner: GraphIndex,
      }

      #[napi]
      impl NativeGraph {
          #[napi(constructor)]
          pub fn new() -> Self {
              Self {
                  inner: GraphIndex::new(),
              }
          }

          #[napi]
          pub fn add_node(&mut self, id: String) {
              self.inner.get_or_create_node(&id);
          }

          #[napi]
          pub fn add_edge(&mut self, source: String, target: String, edge_type: String) {
              self.inner.add_edge(&source, &target, &edge_type);
          }

          /// Performs a single-hop traversal.
          /// Returns unique neighbor IDs.
          #[napi]
          pub fn traverse(&self, sources: Vec<String>, edge_type: Option<String>) -> Vec<String> {
              self.inner.traverse_out(&sources, edge_type.as_deref())
          }

          /// Returns the number of nodes in the interned index.
          /// Useful for debugging hydration.
          #[napi(getter)]
          pub fn node_count(&self) -> u32 {
              // We cast to u32 because exposing usize to JS can be finicky depending on napi version,
              // though napi usually handles numbers well. Safe for V1.
              self.inner.node_count() as u32
          }
      }
    patchStrategy: replace
  - type: write
    path: crates/quack_core/src/topology.rs
    content: |
      --- crates/quack_core/src/topology.rs
      +++ crates/quack_core/src/topology.rs
      @@ -102,4 +102,8 @@
                   .filter_map(|id| self.node_interner.lookup(id).map(|s| s.to_string()))
                   .collect()
           }
      +
      +    pub fn node_count(&self) -> usize {
      +        self.node_interner.len()
      +    }
       }
    patchStrategy: standard-diff
snapshot:
  packages/native/package.json: null
  packages/native/Cargo.toml: null
  packages/native/build.rs: null
  packages/native/src/lib.rs: null
  crates/quack_core/src/topology.rs: |-
    use crate::interner::Interner;
    use bitvec::prelude::*;
    use std::collections::HashMap;

    /// The core Graph Index.
    /// Stores topology in RAM using integer IDs.
    #[derive(Default, Debug)]
    pub struct GraphIndex {
        node_interner: Interner,
        
        // Mapping edge type strings (e.g. "KNOWS") to u8 for compact storage.
        // Limit: 256 edge types per graph in V1.
        edge_type_map: HashMap<String, u8>,
        edge_type_vec: Vec<String>,

        // Forward Graph: Source Node ID -> List of (Target Node ID, Edge Type ID)
        outgoing: Vec<Vec<(u32, u8)>>,
        
        // Reverse Graph: Target Node ID -> List of (Source Node ID, Edge Type ID)
        incoming: Vec<Vec<(u32, u8)>>,

        // Bitmask for soft-deleted nodes.
        // true = deleted (tombstone), false = active.
        tombstones: BitVec,
    }

    impl GraphIndex {
        pub fn new() -> Self {
            Self {
                node_interner: Interner::new(),
                edge_type_map: HashMap::new(),
                edge_type_vec: Vec::new(),
                outgoing: Vec::new(),
                incoming: Vec::new(),
                tombstones: BitVec::new(),
            }
        }

        /// Resolves or creates an internal u32 ID for a node string.
        /// Resizes internal storage if necessary.
        pub fn get_or_create_node(&mut self, id: &str) -> u32 {
            let internal_id = self.node_interner.intern(id);
            let idx = internal_id as usize;

            // Ensure vectors are large enough to hold this node
            if idx >= self.outgoing.len() {
                let new_len = idx + 1;
                self.outgoing.resize_with(new_len, Vec::new);
                self.incoming.resize_with(new_len, Vec::new);
                // Resize tombstones, filling new slots with false (active)
                self.tombstones.resize(new_len, false);
            }
            internal_id
        }

        /// Resolves or creates a u8 ID for an edge type string.
        /// Panics if more than 255 edge types are used (V1 constraint).
        pub fn get_or_create_type(&mut self, type_name: &str) -> u8 {
            if let Some(&id) = self.edge_type_map.get(type_name) {
                return id;
            }
            let id = self.edge_type_vec.len();
            if id > 255 {
                panic!("QuackGraph V1 Limit: Max 256 unique edge types supported.");
            }
            let id_u8 = id as u8;
            self.edge_type_vec.push(type_name.to_string());
            self.edge_type_map.insert(type_name.to_string(), id_u8);
            id_u8
        }

        /// Adds an edge to the graph. 
        /// This is an O(1) append operation (amortized).
        pub fn add_edge(&mut self, source: &str, target: &str, edge_type: &str) {
            let u_src = self.get_or_create_node(source);
            let u_tgt = self.get_or_create_node(target);
            let u_type = self.get_or_create_type(edge_type);

            // Add to forward index
            self.outgoing[u_src as usize].push((u_tgt, u_type));
            
            // Add to reverse index
            self.incoming[u_tgt as usize].push((u_src, u_type));
        }

        /// Generic traversal step.
        /// Given a list of source node IDs (strings), find all neighbors connected by `edge_type`.
        /// Returns unique neighbor IDs (strings).
        pub fn traverse_out(&self, sources: &[String], edge_type: Option<&str>) -> Vec<String> {
            let type_filter = edge_type.and_then(|t| self.edge_type_map.get(t).copied());
            
            let mut result_ids: Vec<u32> = Vec::with_capacity(sources.len() * 2);

            for src_str in sources {
                // If source node doesn't exist in our index, skip it
                if let Some(src_id) = self.node_interner.lookup_id(src_str) {
                    // Check if node is deleted
                    if self.tombstones.get(src_id as usize).as_deref() == Some(&true) {
                        continue;
                    }

                    if let Some(edges) = self.outgoing.get(src_id as usize) {
                        for &(target, type_id) in edges {
                            // Apply edge type filter if present
                            if let Some(req_type) = type_filter {
                                if req_type != type_id {
                                    continue;
                                }
                            }
                            // Check if target is deleted
                            if self.tombstones.get(target as usize).as_deref() == Some(&true) {
                                continue;
                            }
                            result_ids.push(target);
                        }
                    }
                }
            }

            // Deduplicate results
            result_ids.sort_unstable();
            result_ids.dedup();

            // Convert back to strings
            result_ids
                .into_iter()
                .filter_map(|id| self.node_interner.lookup(id).map(|s| s.to_string()))
                .collect()
        }
    }
approved: true
linesAdded: 112
linesRemoved: 0
linesDifference: 112
gitCommittedAt: '2025-12-02T08:17:06.623Z'
status: committed
id: 2
