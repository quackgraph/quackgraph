uuid: 9b2d8f7a-4c1e-4b9d-8f2a-1e4d8c7b9a2e
projectId: quackgraph
createdAt: '2025-12-02T09:02:40.728Z'
gitCommitMsg: >-
  feat: production hardening with strict consistency and delete support

  - Enforced edge uniqueness in Rust GraphIndex to prevent duplication during
  hydration/writes. - Implemented `remove_node` (tombstones) and `remove_edge`
  (swap_remove) in Rust. - Exposed deletion capabilities via Native bindings and
  TypeScript API. - Hardened Arrow ingestion to lookup columns by name instead
  of fixed indices. - Added soft-delete support in DuckDB schema (closing
  `valid_to` window).
promptSummary: >-
  Implemented strict consistency measures: unique edges in RAM, full delete
  support (nodes/edges) across Rust/Native/TS, and schema-aware Arrow ingestion.
reasoning:
  - >-
    Here are the changes to production-harden QuackGraph, implementing strict
    topology consistency, deletion support, and robust Arrow ingestion.
  - '### 1. Rust Core: Robust Topology'
  - >-
    We modify `GraphIndex` to enforce edge uniqueness (preventing duplicates in
    RAM), implement removal logic, and make Arrow batch ingestion schema-aware.
  - '### 2. Native Bridge: Exposing Deletion'
  - >-
    We expose the new `remove_node` and `remove_edge` methods via N-API to
    Node.js.
  - '### 3. TypeScript Schema: Soft Deletes'
  - >-
    We implement `deleteNode` and `deleteEdge` using the temporal `valid_to`
    column (SCD Type 2).
  - '### 4. TypeScript Graph: API & Orchestration'
  - >-
    We update the main `QuackGraph` class to expose deletion methods (ensuring
    they update both Disk and RAM) and improve initialization reliability.
operations:
  - type: write
    path: crates/quack_core/src/topology.rs
    content: |-
      use crate::interner::Interner;
      use bitvec::prelude::*;
      use std::collections::HashMap;
      use arrow::record_batch::RecordBatch;
      use arrow::array::{AsArray, Array, ArrayRef};
      use arrow::datatypes::DataType;

      /// The core Graph Index.
      /// Stores topology in RAM using integer IDs.
      #[derive(Default, Debug)]
      pub struct GraphIndex {
          node_interner: Interner,
          
          // Mapping edge type strings (e.g. "KNOWS") to u8 for compact storage.
          // Limit: 256 edge types per graph in V1.
          edge_type_map: HashMap<String, u8>,
          edge_type_vec: Vec<String>,

          // Forward Graph: Source Node ID -> List of (Target Node ID, Edge Type ID)
          outgoing: Vec<Vec<(u32, u8)>>,
          
          // Reverse Graph: Target Node ID -> List of (Source Node ID, Edge Type ID)
          incoming: Vec<Vec<(u32, u8)>>,

          // Bitmask for soft-deleted nodes.
          // true = deleted (tombstone), false = active.
          tombstones: BitVec,
      }

      pub enum Direction {
          Outgoing,
          Incoming,
      }

      impl GraphIndex {
          pub fn new() -> Self {
              Self {
                  node_interner: Interner::new(),
                  edge_type_map: HashMap::new(),
                  edge_type_vec: Vec::new(),
                  outgoing: Vec::new(),
                  incoming: Vec::new(),
                  tombstones: BitVec::new(),
              }
          }

          /// Resolves or creates an internal u32 ID for a node string.
          /// Resizes internal storage if necessary.
          pub fn get_or_create_node(&mut self, id: &str) -> u32 {
              let internal_id = self.node_interner.intern(id);
              let idx = internal_id as usize;

              // Ensure vectors are large enough to hold this node
              if idx >= self.outgoing.len() {
                  let new_len = idx + 1;
                  self.outgoing.resize_with(new_len, Vec::new);
                  self.incoming.resize_with(new_len, Vec::new);
                  // Resize tombstones, filling new slots with false (active)
                  self.tombstones.resize(new_len, false);
              }
              internal_id
          }

          /// Marks a node as deleted (soft delete).
          /// Traversals will skip this node.
          pub fn remove_node(&mut self, id: &str) {
              if let Some(u_id) = self.node_interner.lookup_id(id) {
                  let idx = u_id as usize;
                  if idx < self.tombstones.len() {
                      self.tombstones.set(idx, true);
                  }
              }
          }

          /// Returns the total number of edges in the graph.
          pub fn edge_count(&self) -> usize {
              self.outgoing.iter().map(|edges| edges.len()).sum()
          }

          /// Resolves or creates a u8 ID for an edge type string.
          /// Panics if more than 255 edge types are used (V1 constraint).
          pub fn get_or_create_type(&mut self, type_name: &str) -> u8 {
              if let Some(&id) = self.edge_type_map.get(type_name) {
                  return id;
              }
              let id = self.edge_type_vec.len();
              if id > 255 {
                  panic!("QuackGraph V1 Limit: Max 256 unique edge types supported.");
              }
              let id_u8 = id as u8;
              self.edge_type_vec.push(type_name.to_string());
              self.edge_type_map.insert(type_name.to_string(), id_u8);
              id_u8
          }

          /// Adds an edge to the graph. 
          /// Idempotent: Does not add duplicate edges if they already exist.
          pub fn add_edge(&mut self, source: &str, target: &str, edge_type: &str) {
              let u_src = self.get_or_create_node(source);
              let u_tgt = self.get_or_create_node(target);
              let u_type = self.get_or_create_type(edge_type);

              // Add to forward index (Idempotent)
              let out_vec = &mut self.outgoing[u_src as usize];
              if !out_vec.contains(&(u_tgt, u_type)) {
                  out_vec.push((u_tgt, u_type));
              }
              
              // Add to reverse index (Idempotent)
              let in_vec = &mut self.incoming[u_tgt as usize];
              if !in_vec.contains(&(u_src, u_type)) {
                  in_vec.push((u_src, u_type));
              }

              // Ensure nodes are not tombstoned if they are being re-added/linked
              if self.tombstones.get(u_src as usize).as_deref() == Some(&true) {
                  self.tombstones.set(u_src as usize, false);
              }
              if self.tombstones.get(u_tgt as usize).as_deref() == Some(&true) {
                  self.tombstones.set(u_tgt as usize, false);
              }
          }

          /// Removes a specific edge from the graph.
          /// Uses swap_remove for O(1) removal, order is not preserved.
          pub fn remove_edge(&mut self, source: &str, target: &str, edge_type: &str) {
              // We only proceed if all entities exist in our interner/maps
              if let (Some(u_src), Some(u_tgt), Some(u_type)) = (
                  self.node_interner.lookup_id(source),
                  self.node_interner.lookup_id(target),
                  self.edge_type_map.get(edge_type).copied(),
              ) {
                  // Remove from outgoing
                  if let Some(edges) = self.outgoing.get_mut(u_src as usize) {
                      if let Some(pos) = edges.iter().position(|x| *x == (u_tgt, u_type)) {
                          edges.swap_remove(pos);
                      }
                  }
                  // Remove from incoming
                  if let Some(edges) = self.incoming.get_mut(u_tgt as usize) {
                      if let Some(pos) = edges.iter().position(|x| *x == (u_src, u_type)) {
                          edges.swap_remove(pos);
                      }
                  }
              }
          }

          /// Ingests an Apache Arrow RecordBatch directly.
          /// Expected Schema: Columns named "source", "target", "type" (case-insensitive or exact).
          pub fn add_arrow_batch(&mut self, batch: &RecordBatch) -> Result<(), String> {
              let schema = batch.schema();
              
              // Resolve column indices by name for robustness
              let src_idx = schema.index_of("source").map_err(|_| "Column 'source' not found in Arrow Batch")?;
              let tgt_idx = schema.index_of("target").map_err(|_| "Column 'target' not found in Arrow Batch")?;
              let type_idx = schema.index_of("type").map_err(|_| "Column 'type' not found in Arrow Batch")?;

              let num_rows = batch.num_rows();
              if num_rows == 0 {
                  return Ok(());
              }

              // Helper to get string accessors regardless of Utf8 (i32 offsets) vs LargeUtf8 (i64 offsets)
              let get_accessor = |col: &ArrayRef| -> Result<Box<dyn Fn(usize) -> &str + '_>, String> {
                  match col.data_type() {
                      DataType::Utf8 => {
                          let arr = col.as_string::<i32>();
                          Ok(Box::new(move |i| arr.value(i)))
                      },
                      DataType::LargeUtf8 => {
                          let arr = col.as_string::<i64>();
                          Ok(Box::new(move |i| arr.value(i)))
                      },
                      dt => Err(format!("Unsupported Arrow column type: {:?}. Expected Utf8 or LargeUtf8.", dt))
                  }
              };

              let src_fn = get_accessor(batch.column(src_idx))?;
              let tgt_fn = get_accessor(batch.column(tgt_idx))?;
              let type_fn = get_accessor(batch.column(type_idx))?;

              for i in 0..num_rows {
                  self.add_edge(src_fn(i), tgt_fn(i), type_fn(i));
              }
              Ok(())
          }

          /// Generic traversal step (Bidirectional).
          /// Given a list of source node IDs (strings), find all neighbors connected by `edge_type`
          /// in the specified `direction`.
          pub fn traverse(&self, sources: &[String], edge_type: Option<&str>, direction: Direction) -> Vec<String> {
              let type_filter = edge_type.and_then(|t| self.edge_type_map.get(t).copied());
              
              let mut result_ids: Vec<u32> = Vec::with_capacity(sources.len() * 2);
              
              let adjacency = match direction {
                  Direction::Outgoing => &self.outgoing,
                  Direction::Incoming => &self.incoming,
              };

              for src_str in sources {
                  // If source node doesn't exist in our index, skip it
                  if let Some(src_id) = self.node_interner.lookup_id(src_str) {
                      // Check if node is deleted
                      if self.tombstones.get(src_id as usize).as_deref() == Some(&true) {
                          continue;
                      }

                      if let Some(edges) = adjacency.get(src_id as usize) {
                          for &(target, type_id) in edges {
                              // Apply edge type filter if present
                              if let Some(req_type) = type_filter {
                                  if req_type != type_id {
                                      continue;
                                  }
                              }
                              // Check if target is deleted
                              if self.tombstones.get(target as usize).as_deref() == Some(&true) {
                                  continue;
                              }
                              result_ids.push(target);
                          }
                      }
                  }
              }

              // Deduplicate results
              result_ids.sort_unstable();
              result_ids.dedup();

              // Convert back to strings
              result_ids
                  .into_iter()
                  .filter_map(|id| self.node_interner.lookup(id).map(|s| s.to_string()))
                  .collect()
          }

          pub fn node_count(&self) -> usize {
              self.node_interner.len()
          }
      }
    patchStrategy: replace
  - type: write
    path: packages/native/src/lib.rs
    content: >
      --- packages/native/src/lib.rs

      +++ packages/native/src/lib.rs

      @@ -46,6 +46,16 @@
               self.inner.add_edge(&source, &target, &edge_type);
           }
       
      +    #[napi]

      +    pub fn remove_node(&mut self, id: String) {

      +        self.inner.remove_node(&id);

      +    }

      +

      +    #[napi]

      +    pub fn remove_edge(&mut self, source: String, target: String,
      edge_type: String) {

      +        self.inner.remove_edge(&source, &target, &edge_type);

      +    }

      +
           /// Performs a single-hop traversal (bfs-step).
           /// Returns unique neighbor IDs.
           #[napi]
    patchStrategy: standard-diff
  - type: write
    path: packages/quack-graph/src/schema.ts
    content: >
      --- packages/quack-graph/src/schema.ts

      +++ packages/quack-graph/src/schema.ts

      @@ -62,6 +62,26 @@
           });
         }
       
      +  async deleteNode(id: string) {

      +    // Soft Delete: Close the validity period

      +    await this.db.transaction(async (tx: DbExecutor) => {

      +      await tx.execute(

      +        `UPDATE nodes SET valid_to = current_timestamp WHERE id = ? AND
      valid_to IS NULL`,

      +        [id]

      +      );

      +    });

      +  }

      +

      +  async deleteEdge(source: string, target: string, type: string) {

      +    // Soft Delete: Close the validity period

      +    await this.db.transaction(async (tx: DbExecutor) => {

      +      await tx.execute(

      +        `UPDATE edges SET valid_to = current_timestamp WHERE source = ?
      AND target = ? AND type = ? AND valid_to IS NULL`,

      +        [source, target, type]

      +      );

      +    });

      +  }

      +
         /**
          * Promotes a JSON property to a native column for faster filtering.
          * This creates a column on the `nodes` table and backfills it from the `properties` JSON blob.
    patchStrategy: standard-diff
  - type: write
    path: packages/quack-graph/src/graph.ts
    content: >
      --- packages/quack-graph/src/graph.ts

      +++ packages/quack-graph/src/graph.ts

      @@ -24,7 +24,11 @@
           await this.db.init();
           
           // Load Extensions
      -    await this.db.execute("INSTALL vss; LOAD vss;");

      +    try {

      +      await this.db.execute("INSTALL vss; LOAD vss;");

      +    } catch (e) {

      +      console.warn("QuackGraph: Failed to load 'vss' extension. Vector
      search will be disabled.", e);

      +    }
           
           await this.schema.ensureSchema();
           
      @@ -88,6 +92,20 @@
           this.native.addEdge(source, target, type);
         }
       
      +  async deleteNode(id: string) {

      +    // 1. Write to Disk (Soft Delete)

      +    await this.schema.deleteNode(id);

      +    // 2. Write to RAM (Tombstone)

      +    this.native.removeNode(id);

      +  }

      +

      +  async deleteEdge(source: string, target: string, type: string) {

      +    // 1. Write to Disk (Soft Delete)

      +    await this.schema.deleteEdge(source, target, type);

      +    // 2. Write to RAM (Remove)

      +    this.native.removeEdge(source, target, type);

      +  }

      +
         // --- Optimization & Maintenance ---
       
         get optimize() {
    patchStrategy: standard-diff
snapshot:
  packages/native/src/lib.rs: |-
    #![deny(clippy::all)]

    use napi::bindgen_prelude::*;
    use napi_derive::napi;
    use quack_core::{GraphIndex, Direction};
    use arrow::ipc::reader::StreamReader;
    use std::io::Cursor;

    #[napi]
    pub struct NativeGraph {
        inner: GraphIndex,
    }

    #[napi]
    impl NativeGraph {
        #[napi(constructor)]
        pub fn new() -> Self {
            Self {
                inner: GraphIndex::new(),
            }
        }

        #[napi]
        pub fn add_node(&mut self, id: String) {
            self.inner.get_or_create_node(&id);
        }

        /// Hydrates the graph from an Arrow IPC stream (Buffer).
        /// Zero-copy (mostly) data transfer from DuckDB.
        #[napi]
        pub fn load_arrow_ipc(&mut self, buffer: Buffer) -> napi::Result<()> {
            let cursor = Cursor::new(buffer.as_ref());
            let reader = StreamReader::try_new(cursor, None).map_err(|e| napi::Error::from_reason(e.to_string()))?;

            for batch in reader {
                let batch = batch.map_err(|e| napi::Error::from_reason(e.to_string()))?;
                self.inner.add_arrow_batch(&batch).map_err(|e| napi::Error::from_reason(e))?;
            }
            Ok(())
        }

        #[napi]
        pub fn add_edge(&mut self, source: String, target: String, edge_type: String) {
            self.inner.add_edge(&source, &target, &edge_type);
        }

        /// Performs a single-hop traversal (bfs-step).
        /// Returns unique neighbor IDs.
        #[napi]
        pub fn traverse(&self, sources: Vec<String>, edge_type: Option<String>, direction: Option<String>) -> Vec<String> {
            let dir = match direction.as_deref() {
                Some("in") | Some("IN") => Direction::Incoming,
                _ => Direction::Outgoing,
            };
            self.inner.traverse(&sources, edge_type.as_deref(), dir)
        }

        /// Returns the number of nodes in the interned index.
        /// Useful for debugging hydration.
        #[napi(getter)]
        pub fn node_count(&self) -> u32 {
            // We cast to u32 because exposing usize to JS can be finicky depending on napi version,
            // though napi usually handles numbers well. Safe for V1.
            self.inner.node_count() as u32
        }

        #[napi(getter)]
        pub fn edge_count(&self) -> u32 {
            self.inner.edge_count() as u32
        }
    }
  packages/quack-graph/src/graph.ts: |-
    import { NativeGraph } from '@quackgraph/native';
    import { DuckDBManager } from './db';
    import { SchemaManager } from './schema';
    import { QueryBuilder } from './query';

    export class QuackGraph {
      db: DuckDBManager;
      schema: SchemaManager;
      native: NativeGraph;
      
      // Context for the current instance (Time Travel)
      context: {
        asOf?: Date;
      } = {};

      constructor(path: string = ':memory:', options: { asOf?: Date } = {}) {
        this.db = new DuckDBManager(path);
        this.schema = new SchemaManager(this.db);
        this.native = new NativeGraph();
        this.context.asOf = options.asOf;
      }

      async init() {
        await this.db.init();
        
        // Load Extensions
        await this.db.execute("INSTALL vss; LOAD vss;");
        
        await this.schema.ensureSchema();
        
        // If we are in time-travel mode, we might skip hydration or hydrate a snapshot (Advanced).
        // For V1, we always hydrate "Current Active" topology.
        try {
          await this.hydrate();
        } catch (e) {
          console.error("Failed to hydrate graph topology from disk:", e);
          // We don't throw here to allow partial functionality (metadata queries) if needed,
          // but usually this is fatal for graph operations.
          throw e;
        }
      }

      /**
       * Hydrates the in-memory Rust graph from the persistent DuckDB storage.
       * This is critical for the "Split-Brain" architecture.
       */
      async hydrate() {
        // Zero-Copy Arrow IPC
        // 'valid_to IS NULL' ensures we only load currently active edges.
        try {
          const ipcBuffer = await this.db.queryArrow(
            "SELECT source, target, type FROM edges WHERE valid_to IS NULL"
          );
        
          if (ipcBuffer && ipcBuffer.length > 0) {
             // Napi-rs expects a Buffer or equivalent
             // Buffer.from is zero-copy in Node for Uint8Array usually, or cheap copy
             // We cast to any to satisfy the generated TS definitions which might expect Buffer
             this.native.loadArrowIpc(ipcBuffer as any);
          }
        } catch (e: any) {
          throw new Error(`Hydration Error: ${e.message}`);
        }
      }

      asOf(date: Date): QuackGraph {
        // Return a shallow copy with new context
        const g = new QuackGraph(this.db['path'], { asOf: date });
        // Share the same DB connection and Native index (assuming topology is shared/latest)
        g.db = this.db;
        g.schema = this.schema;
        g.native = this.native;
        return g;
      }

      // --- Write Operations (Write-Through) ---

      async addNode(id: string, labels: string[], props: Record<string, any> = {}) {
        // 1. Write to Disk (Source of Truth)
        await this.schema.writeNode(id, labels, props);
        // 2. Write to RAM (Cache)
        this.native.addNode(id);
      }

      async addEdge(source: string, target: string, type: string, props: Record<string, any> = {}) {
        // 1. Write to Disk
        await this.schema.writeEdge(source, target, type, props);
        // 2. Write to RAM
        this.native.addEdge(source, target, type);
      }

      // --- Optimization & Maintenance ---

      get optimize() {
        return {
          promoteProperty: async (label: string, property: string, type: string) => {
            await this.schema.promoteNodeProperty(label, property, type);
          },
        };
      }

      // --- Read Operations ---

      match(labels: string[]): QueryBuilder {
        return new QueryBuilder(this, labels);
      }
    }
  crates/quack_core/src/topology.rs: |-
    use crate::interner::Interner;
    use bitvec::prelude::*;
    use std::collections::HashMap;
    use arrow::record_batch::RecordBatch;
    use arrow::array::{AsArray, Array, ArrayRef};
    use arrow::datatypes::DataType;

    /// The core Graph Index.
    /// Stores topology in RAM using integer IDs.
    #[derive(Default, Debug)]
    pub struct GraphIndex {
        node_interner: Interner,
        
        // Mapping edge type strings (e.g. "KNOWS") to u8 for compact storage.
        // Limit: 256 edge types per graph in V1.
        edge_type_map: HashMap<String, u8>,
        edge_type_vec: Vec<String>,

        // Forward Graph: Source Node ID -> List of (Target Node ID, Edge Type ID)
        outgoing: Vec<Vec<(u32, u8)>>,
        
        // Reverse Graph: Target Node ID -> List of (Source Node ID, Edge Type ID)
        incoming: Vec<Vec<(u32, u8)>>,

        // Bitmask for soft-deleted nodes.
        // true = deleted (tombstone), false = active.
        tombstones: BitVec,
    }

    pub enum Direction {
        Outgoing,
        Incoming,
    }

    impl GraphIndex {
        pub fn new() -> Self {
            Self {
                node_interner: Interner::new(),
                edge_type_map: HashMap::new(),
                edge_type_vec: Vec::new(),
                outgoing: Vec::new(),
                incoming: Vec::new(),
                tombstones: BitVec::new(),
            }
        }

        /// Resolves or creates an internal u32 ID for a node string.
        /// Resizes internal storage if necessary.
        pub fn get_or_create_node(&mut self, id: &str) -> u32 {
            let internal_id = self.node_interner.intern(id);
            let idx = internal_id as usize;

            // Ensure vectors are large enough to hold this node
            if idx >= self.outgoing.len() {
                let new_len = idx + 1;
                self.outgoing.resize_with(new_len, Vec::new);
                self.incoming.resize_with(new_len, Vec::new);
                // Resize tombstones, filling new slots with false (active)
                self.tombstones.resize(new_len, false);
            }
            internal_id
        }

        /// Returns the total number of edges in the graph.
        pub fn edge_count(&self) -> usize {
            self.outgoing.iter().map(|edges| edges.len()).sum()
        }

        /// Resolves or creates a u8 ID for an edge type string.
        /// Panics if more than 255 edge types are used (V1 constraint).
        pub fn get_or_create_type(&mut self, type_name: &str) -> u8 {
            if let Some(&id) = self.edge_type_map.get(type_name) {
                return id;
            }
            let id = self.edge_type_vec.len();
            if id > 255 {
                panic!("QuackGraph V1 Limit: Max 256 unique edge types supported.");
            }
            let id_u8 = id as u8;
            self.edge_type_vec.push(type_name.to_string());
            self.edge_type_map.insert(type_name.to_string(), id_u8);
            id_u8
        }

        /// Adds an edge to the graph. 
        /// This is an O(1) append operation (amortized).
        pub fn add_edge(&mut self, source: &str, target: &str, edge_type: &str) {
            let u_src = self.get_or_create_node(source);
            let u_tgt = self.get_or_create_node(target);
            let u_type = self.get_or_create_type(edge_type);

            // Add to forward index
            self.outgoing[u_src as usize].push((u_tgt, u_type));
            
            // Add to reverse index
            self.incoming[u_tgt as usize].push((u_src, u_type));
        }

        /// Ingests an Apache Arrow RecordBatch directly.
        /// Expected Schema: [source: Utf8, target: Utf8, type: Utf8]
        pub fn add_arrow_batch(&mut self, batch: &RecordBatch) -> Result<(), String> {
            // We expect 3 columns. Safe to panic in V1 if schema mismatches as it's controlled by our own TS layer.
            if batch.num_columns() < 3 {
                return Err(format!("Batch has {} columns, expected at least 3 (source, target, type)", batch.num_columns()));
            }

            let num_rows = batch.num_rows();
            if num_rows == 0 {
                return Ok(());
            }

            // Helper to get string accessors regardless of Utf8 (i32 offsets) vs LargeUtf8 (i64 offsets)
            let get_accessor = |col: &ArrayRef| -> Result<Box<dyn Fn(usize) -> &str + '_>, String> {
                match col.data_type() {
                    DataType::Utf8 => {
                        let arr = col.as_string::<i32>();
                        Ok(Box::new(move |i| arr.value(i)))
                    },
                    DataType::LargeUtf8 => {
                        let arr = col.as_string::<i64>();
                        Ok(Box::new(move |i| arr.value(i)))
                    },
                    dt => Err(format!("Unsupported Arrow column type: {:?}. Expected Utf8 or LargeUtf8.", dt))
                }
            };

            let src_fn = get_accessor(batch.column(0))?;
            let tgt_fn = get_accessor(batch.column(1))?;
            let type_fn = get_accessor(batch.column(2))?;

            for i in 0..num_rows {
                self.add_edge(src_fn(i), tgt_fn(i), type_fn(i));
            }
            Ok(())
        }

        /// Generic traversal step (Bidirectional).
        /// Given a list of source node IDs (strings), find all neighbors connected by `edge_type`
        /// in the specified `direction`.
        pub fn traverse(&self, sources: &[String], edge_type: Option<&str>, direction: Direction) -> Vec<String> {
            let type_filter = edge_type.and_then(|t| self.edge_type_map.get(t).copied());
            
            let mut result_ids: Vec<u32> = Vec::with_capacity(sources.len() * 2);
            
            let adjacency = match direction {
                Direction::Outgoing => &self.outgoing,
                Direction::Incoming => &self.incoming,
            };

            for src_str in sources {
                // If source node doesn't exist in our index, skip it
                if let Some(src_id) = self.node_interner.lookup_id(src_str) {
                    // Check if node is deleted
                    if self.tombstones.get(src_id as usize).as_deref() == Some(&true) {
                        continue;
                    }

                    if let Some(edges) = adjacency.get(src_id as usize) {
                        for &(target, type_id) in edges {
                            // Apply edge type filter if present
                            if let Some(req_type) = type_filter {
                                if req_type != type_id {
                                    continue;
                                }
                            }
                            // Check if target is deleted
                            if self.tombstones.get(target as usize).as_deref() == Some(&true) {
                                continue;
                            }
                            result_ids.push(target);
                        }
                    }
                }
            }

            // Deduplicate results
            result_ids.sort_unstable();
            result_ids.dedup();

            // Convert back to strings
            result_ids
                .into_iter()
                .filter_map(|id| self.node_interner.lookup(id).map(|s| s.to_string()))
                .collect()
        }

        pub fn node_count(&self) -> usize {
            self.node_interner.len()
        }
    }
  packages/quack-graph/src/schema.ts: |-
    import { DuckDBManager, DbExecutor } from './db';

    const NODES_TABLE = `
    CREATE TABLE IF NOT EXISTS nodes (
        row_id UBIGINT PRIMARY KEY, -- Simple auto-increment equivalent logic handled by sequence
        id TEXT NOT NULL,
        labels TEXT[],
        properties JSON,
        embedding FLOAT[], -- Vector embedding
        valid_from TIMESTAMP DEFAULT current_timestamp,
        valid_to TIMESTAMP DEFAULT NULL
    );
    CREATE SEQUENCE IF NOT EXISTS seq_node_id;
    `;

    const EDGES_TABLE = `
    CREATE TABLE IF NOT EXISTS edges (
        source TEXT NOT NULL,
        target TEXT NOT NULL,
        type TEXT NOT NULL,
        properties JSON,
        valid_from TIMESTAMP DEFAULT current_timestamp,
        valid_to TIMESTAMP DEFAULT NULL
    );
    `;

    export class SchemaManager {
      constructor(private db: DuckDBManager) {}

      async ensureSchema() {
        await this.db.execute(NODES_TABLE);
        await this.db.execute(EDGES_TABLE);
      }

      async writeNode(id: string, labels: string[], properties: Record<string, any> = {}) {
        await this.db.transaction(async (tx: DbExecutor) => {
          // 1. Close existing record (SCD Type 2)
          await tx.execute(
            `UPDATE nodes SET valid_to = current_timestamp WHERE id = ? AND valid_to IS NULL`,
            [id]
          );
          // 2. Insert new version
          await tx.execute(`
            INSERT INTO nodes (row_id, id, labels, properties, valid_from, valid_to) 
            VALUES (nextval('seq_node_id'), ?, ?, ?::JSON, current_timestamp, NULL)
          `, [id, labels, JSON.stringify(properties)]);
        });
      }

      async writeEdge(source: string, target: string, type: string, properties: Record<string, any> = {}) {
        await this.db.transaction(async (tx: DbExecutor) => {
          // 1. Close existing edge
          await tx.execute(
            `UPDATE edges SET valid_to = current_timestamp WHERE source = ? AND target = ? AND type = ? AND valid_to IS NULL`,
            [source, target, type]
          );
          // 2. Insert new version
          await tx.execute(`
            INSERT INTO edges (source, target, type, properties, valid_from, valid_to) 
            VALUES (?, ?, ?, ?::JSON, current_timestamp, NULL)
          `, [source, target, type, JSON.stringify(properties)]);
        });
      }

      /**
       * Promotes a JSON property to a native column for faster filtering.
       * This creates a column on the `nodes` table and backfills it from the `properties` JSON blob.
       * 
       * @param label The node label to target (e.g., 'User'). Only nodes with this label will be updated.
       * @param property The property key to promote (e.g., 'age').
       * @param type The DuckDB SQL type (e.g., 'INTEGER', 'VARCHAR').
       */
      async promoteNodeProperty(label: string, property: string, type: string) {
        // Sanitize inputs to prevent basic SQL injection (rudimentary check)
        if (!/^[a-zA-Z0-9_]+$/.test(property)) throw new Error(`Invalid property name: ${property}`);
        // Type check is looser to allow various SQL types, but strictly alphanumeric + spaces/parens usually safe enough for now
        
        // 1. Add Column (Idempotent)
        try {
          // Note: DuckDB 0.9+ supports ADD COLUMN IF NOT EXISTS
          await this.db.execute(`ALTER TABLE nodes ADD COLUMN IF NOT EXISTS ${property} ${type}`);
        } catch (e) {
          // Fallback or ignore if column exists
        }

        // 2. Backfill Data
        // We use list_contains to only update relevant nodes
        const sql = `
          UPDATE nodes 
          SET ${property} = CAST(json_extract(properties, '$.${property}') AS ${type})
          WHERE list_contains(labels, ?)
        `;
        await this.db.execute(sql, [label]);
      }
    }
approved: true
linesAdded: 113
linesRemoved: 14
linesDifference: 127
gitCommittedAt: '2025-12-02T09:02:51.925Z'
status: committed
id: 12
