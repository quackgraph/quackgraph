uuid: e6e0b3c6-3d6d-4952-b133-c1c6823136ac
projectId: quackgraph
createdAt: '2025-12-02T05:33:18.889Z'
gitCommitMsg: >-
  feat(core): implement quack_core rust crate and graph topology

  Initialized the Cargo workspace and the `quack_core` library. Implemented the
  `Interner` for efficient String<->u32 mapping and `GraphIndex` for in-memory
  adjacency lists (CSR-like) with support for node tombstones and edge types.
  This forms the foundation of the in-memory traversal engine.
promptSummary: >-
  Resending the implementation of Part 1 (The Rust Brain) in the correct format.
  This includes scaffolding the Cargo workspace and implementing the core graph
  data structures in the `quack_core` crate.
reasoning:
  - >-
    Of course. Here is the response in the correct format, creating the Rust
    core for QuackGraph as specified in Part 1 of the plan.
  - >-
    First, I'll set up the root `Cargo.toml` to define our monorepo as a Cargo
    workspace. This allows `cargo` commands at the root to manage all Rust
    packages.
  - >-
    Next, I'll define the `quack_core` package itself. This `Cargo.toml`
    specifies its dependencies: `thiserror` for error handling, `serde` for
    future serialization, and `bitvec` for an efficient in-memory representation
    of node tombstones.
  - >-
    Now for the core logic. The `Interner` is a critical performance component.
    It translates string IDs (like UUIDs from DuckDB) into compact `u32`
    integers, which are necessary for fast, cache-friendly lookups in the main
    graph index. This bidirectional map ensures O(1) lookups in both directions.
  - >-
    This is the "brain" of QuackGraph. The `GraphIndex` struct stores the graph
    topology in a CSR-like format (adjacency lists). It maintains separate
    `incoming` and `outgoing` vectors for fast bidirectional traversals (`.in()`
    and `.out()`). It uses the `Interner` to work with integer IDs and a
    `BitVec` for tracking soft-deletions (tombstones).
  - >-
    Finally, I'll create the library's entry point, `lib.rs`, which makes the
    core components public so they can be used by other crates (like our
    upcoming `native` NAPI package).
operations:
  - type: write
    path: Cargo.toml
    content: |-
      [workspace]
      members = [
          "crates/*",
          "packages/native"
      ]
      resolver = "2"
    patchStrategy: replace
  - type: write
    path: crates/quack_core/Cargo.toml
    content: |-
      [package]
      name = "quack_core"
      version = "0.1.0"
      edition = "2021"

      [dependencies]
      thiserror = "1.0"
      serde = { version = "1.0", features = ["derive"] }
      bitvec = "1.0"
    patchStrategy: replace
  - type: write
    path: crates/quack_core/src/interner.rs
    content: >-
      use std::collections::HashMap;


      /// A bidirectional map between String IDs and u32 internal indices.

      /// Used to convert DuckDB UUIDs/Strings into efficient integers for the
      graph topology.

      #[derive(Default, Debug, Clone)]

      pub struct Interner {
          map: HashMap<String, u32>,
          vec: Vec<String>,
      }


      impl Interner {
          pub fn new() -> Self {
              Self {
                  map: HashMap::new(),
                  vec: Vec::new(),
              }
          }

          /// Interns a string: returns existing ID if present, or creates a new one.
          /// O(1) average case.
          pub fn intern(&mut self, name: &str) -> u32 {
              if let Some(&id) = self.map.get(name) {
                  return id;
              }
              let id = self.vec.len() as u32;
              let key = name.to_string();
              self.vec.push(key.clone());
              self.map.insert(key, id);
              id
          }

          /// Reverse lookup: u32 -> String.
          /// O(1) worst case.
          pub fn lookup(&self, id: u32) -> Option<&str> {
              self.vec.get(id as usize).map(|s| s.as_str())
          }

          /// Looks up the u32 ID for a given string name.
          /// O(1) average case.
          pub fn lookup_id(&self, name: &str) -> Option<u32> {
              self.map.get(name).copied()
          }

          /// Current number of interned items.
          pub fn len(&self) -> usize {
              self.vec.len()
          }

          pub fn is_empty(&self) -> bool {
              self.vec.is_empty()
          }
      }
    patchStrategy: replace
  - type: write
    path: crates/quack_core/src/topology.rs
    content: |-
      use crate::interner::Interner;
      use bitvec::prelude::*;
      use std::collections::HashMap;

      /// The core Graph Index.
      /// Stores topology in RAM using integer IDs.
      #[derive(Default, Debug)]
      pub struct GraphIndex {
          node_interner: Interner,
          
          // Mapping edge type strings (e.g. "KNOWS") to u8 for compact storage.
          // Limit: 256 edge types per graph in V1.
          edge_type_map: HashMap<String, u8>,
          edge_type_vec: Vec<String>,

          // Forward Graph: Source Node ID -> List of (Target Node ID, Edge Type ID)
          outgoing: Vec<Vec<(u32, u8)>>,
          
          // Reverse Graph: Target Node ID -> List of (Source Node ID, Edge Type ID)
          incoming: Vec<Vec<(u32, u8)>>,

          // Bitmask for soft-deleted nodes.
          // true = deleted (tombstone), false = active.
          tombstones: BitVec,
      }

      impl GraphIndex {
          pub fn new() -> Self {
              Self {
                  node_interner: Interner::new(),
                  edge_type_map: HashMap::new(),
                  edge_type_vec: Vec::new(),
                  outgoing: Vec::new(),
                  incoming: Vec::new(),
                  tombstones: BitVec::new(),
              }
          }

          /// Resolves or creates an internal u32 ID for a node string.
          /// Resizes internal storage if necessary.
          pub fn get_or_create_node(&mut self, id: &str) -> u32 {
              let internal_id = self.node_interner.intern(id);
              let idx = internal_id as usize;

              // Ensure vectors are large enough to hold this node
              if idx >= self.outgoing.len() {
                  let new_len = idx + 1;
                  self.outgoing.resize_with(new_len, Vec::new);
                  self.incoming.resize_with(new_len, Vec::new);
                  // Resize tombstones, filling new slots with false (active)
                  self.tombstones.resize(new_len, false);
              }
              internal_id
          }

          /// Resolves or creates a u8 ID for an edge type string.
          /// Panics if more than 255 edge types are used (V1 constraint).
          pub fn get_or_create_type(&mut self, type_name: &str) -> u8 {
              if let Some(&id) = self.edge_type_map.get(type_name) {
                  return id;
              }
              let id = self.edge_type_vec.len();
              if id > 255 {
                  panic!("QuackGraph V1 Limit: Max 256 unique edge types supported.");
              }
              let id_u8 = id as u8;
              self.edge_type_vec.push(type_name.to_string());
              self.edge_type_map.insert(type_name.to_string(), id_u8);
              id_u8
          }

          /// Adds an edge to the graph. 
          /// This is an O(1) append operation (amortized).
          pub fn add_edge(&mut self, source: &str, target: &str, edge_type: &str) {
              let u_src = self.get_or_create_node(source);
              let u_tgt = self.get_or_create_node(target);
              let u_type = self.get_or_create_type(edge_type);

              // Add to forward index
              self.outgoing[u_src as usize].push((u_tgt, u_type));
              
              // Add to reverse index
              self.incoming[u_tgt as usize].push((u_src, u_type));
          }

          /// Generic traversal step.
          /// Given a list of source node IDs (strings), find all neighbors connected by `edge_type`.
          /// Returns unique neighbor IDs (strings).
          pub fn traverse_out(&self, sources: &[String], edge_type: Option<&str>) -> Vec<String> {
              let type_filter = edge_type.and_then(|t| self.edge_type_map.get(t).copied());
              
              let mut result_ids: Vec<u32> = Vec::with_capacity(sources.len() * 2);

              for src_str in sources {
                  // If source node doesn't exist in our index, skip it
                  if let Some(src_id) = self.node_interner.lookup_id(src_str) {
                      // Check if node is deleted
                      if self.tombstones.get(src_id as usize).as_deref() == Some(&true) {
                          continue;
                      }

                      if let Some(edges) = self.outgoing.get(src_id as usize) {
                          for &(target, type_id) in edges {
                              // Apply edge type filter if present
                              if let Some(req_type) = type_filter {
                                  if req_type != type_id {
                                      continue;
                                  }
                              }
                              // Check if target is deleted
                              if self.tombstones.get(target as usize).as_deref() == Some(&true) {
                                  continue;
                              }
                              result_ids.push(target);
                          }
                      }
                  }
              }

              // Deduplicate results
              result_ids.sort_unstable();
              result_ids.dedup();

              // Convert back to strings
              result_ids
                  .into_iter()
                  .filter_map(|id| self.node_interner.lookup(id).map(|s| s.to_string()))
                  .collect()
          }
      }
    patchStrategy: replace
  - type: write
    path: crates/quack_core/src/lib.rs
    content: |-
      pub mod interner;
      pub mod topology;

      pub use interner::Interner;
      pub use topology::GraphIndex;
    patchStrategy: replace
snapshot:
  Cargo.toml: null
  crates/quack_core/Cargo.toml: null
  crates/quack_core/src/interner.rs: null
  crates/quack_core/src/topology.rs: null
  crates/quack_core/src/lib.rs: null
approved: true
linesAdded: 202
linesRemoved: 0
linesDifference: 202
gitCommittedAt: '2025-12-02T08:17:06.623Z'
status: committed
id: 1
