uuid: 4a2f8c1b-9e3d-4c5a-8b2e-1f3a5c7d9e0f
projectId: quackgraph
createdAt: '2025-12-02T12:39:33.418Z'
gitCommitMsg: >-
  test: Implement core Unit and Integration suites for Persistence and
  Concurrency.

  - Added robust cleanup logic in helpers.ts. - Implemented unit tests for core
  graph ops (CRUD, Idempotency). - Implemented integration tests for Persistence
  (Hydration, Snapshots, Soft Deletes). - Implemented integration tests for
  Concurrency (Async Writes). - Merged lifecycle.test.ts into
  persistence.test.ts.
promptSummary: >-
  Executed Part 1 (Utils, Unit) and Part 2 (Persistence, Concurrency).
  Consolidated redundant `lifecycle.test.ts` into `persistence.test.ts` and
  enhanced helpers for robust disk cleanup.
reasoning:
  - >-
    Part 1 and Part 2 of the plan focus on establishing the test infrastructure
    and verifying the core persistence and concurrency models of the
    "Split-Brain" architecture.
  - >-
    I will implement the test utilities, the core unit tests, and the
    integration tests for persistence and concurrency. I noticed that
    `test/integration/lifecycle.test.ts` and
    `test/integration/persistence.test.ts` in the provided context have
    significant overlap (both test hydration). I will consolidate them into
    `test/integration/persistence.test.ts` to avoid redundancy and ensure a
    single source of truth for persistence logic, and delete
    `lifecycle.test.ts`.
  - '### Steps Taken'
  - >-
    1.  **Refine `test/utils/helpers.ts`**: Ensure robust cleanup of DuckDB WAL
    and temporary files to prevent "noisy neighbor" test failures.
  - >-
    2.  **Implement `test/unit/graph.test.ts`**: Verify in-memory core behavior
    (CRUD, Idempotency, Soft Delete logic).
  - >-
    3.  **Consolidate `test/integration/persistence.test.ts`**: Combine
    hydration, soft-delete persistence, snapshotting, and special character
    handling into one suite.
  - >-
    4.  **Implement `test/integration/concurrency.test.ts`**: Verify
    thread-safety (or async-safety) of the single-writer DuckDB model under
    load.
  - '5.  **Clean up**: Delete the redundant `test/integration/lifecycle.test.ts`.'
operations:
  - type: write
    path: test/utils/helpers.ts
    content: >-
      import { unlink } from 'node:fs/promises';

      import { join } from 'node:path';

      import { tmpdir } from 'node:os';

      import { QuackGraph } from '../../packages/quack-graph/src/index';


      export const getTempPath = (prefix = 'quack-test') => {
        const uuid = crypto.randomUUID();
        return join(tmpdir(), `${prefix}-${uuid}.duckdb`);
      };


      export const createGraph = async (mode: 'memory' | 'disk' = 'memory',
      dbName?: string) => {
        const path = mode === 'memory' ? ':memory:' : getTempPath(dbName);
        const graph = new QuackGraph(path);
        await graph.init();
        return { graph, path };
      };


      export const cleanupGraph = async (path: string) => {
        if (path === ':memory:') return;
        try {
          // Aggressively clean up main DB file and potential WAL/tmp files
          await unlink(path).catch(() => {});
          await unlink(`${path}.wal`).catch(() => {});
          await unlink(`${path}.tmp`).catch(() => {});
          // Snapshots are sometimes saved as .bin
          await unlink(`${path}.bin`).catch(() => {});
        } catch (_e) {
          // Ignore errors if file doesn't exist
        }
      };


      /**
       * Wait for a short duration. Useful if we need to ensure timestamps differ slightly
       * (though QuackGraph uses microsecond precision usually, node might be ms).
       */
      export const sleep = (ms: number) => new Promise((resolve) =>
      setTimeout(resolve, ms));


      /**
       * Seeds a basic graph with a few nodes and edges for testing traversals.
       * A -> B -> C
       *      |
       *      v
       *      D
       */
      export const seedBasicGraph = async (g: QuackGraph) => {
        await g.addNode('a', ['Node']);
        await g.addNode('b', ['Node']);
        await g.addNode('c', ['Node']);
        await g.addNode('d', ['Node']);
        await g.addEdge('a', 'b', 'NEXT');
        await g.addEdge('b', 'c', 'NEXT');
        await g.addEdge('b', 'd', 'NEXT');
      };
    patchStrategy: replace
  - type: write
    path: test/unit/graph.test.ts
    content: |-
      import { describe, test, expect, beforeEach, afterEach } from 'bun:test';
      import { createGraph, cleanupGraph } from '../utils/helpers';
      import type { QuackGraph } from '../../packages/quack-graph/src/index';

      describe('Unit: QuackGraph Core', () => {
        let g: QuackGraph;
        let path: string;

        beforeEach(async () => {
          const setup = await createGraph('memory');
          g = setup.graph;
          path = setup.path;
        });

        afterEach(async () => {
          await cleanupGraph(path);
        });

        test('should initialize with zero nodes', () => {
          expect(g.native.nodeCount).toBe(0);
          expect(g.native.edgeCount).toBe(0);
        });

        test('should add nodes and increment count', async () => {
          await g.addNode('u:1', ['User'], { name: 'Alice' });
          await g.addNode('u:2', ['User'], { name: 'Bob' });
          
          // Check Rust Index
          expect(g.native.nodeCount).toBe(2);
          
          // Check DuckDB Storage
          const rows = await g.db.query('SELECT * FROM nodes');
          expect(rows.length).toBe(2);
          expect(rows.find(r => r.id === 'u:1').properties).toContain('Alice');
        });

        test('should add edges and support traversal', async () => {
          await g.addNode('a', ['Node']);
          await g.addNode('b', ['Node']);
          await g.addEdge('a', 'b', 'LINK');

          expect(g.native.edgeCount).toBe(1);

          // Simple manual traversal check using native directly
          const neighbors = g.native.traverse(['a'], 'LINK', 'out');
          expect(neighbors).toEqual(['b']);
        });

        test('should be idempotent when adding same edge', async () => {
          await g.addNode('a', ['Node']);
          await g.addNode('b', ['Node']);
          
          await g.addEdge('a', 'b', 'LINK');
          await g.addEdge('a', 'b', 'LINK'); // Duplicate

          expect(g.native.edgeCount).toBe(1);
          const neighbors = g.native.traverse(['a'], 'LINK', 'out');
          expect(neighbors).toEqual(['b']);
        });

        test('should soft delete nodes and stop traversal', async () => {
          await g.addNode('a', ['Node']);
          await g.addNode('b', ['Node']);
          await g.addEdge('a', 'b', 'LINK');

          let neighbors = g.native.traverse(['a'], 'LINK', 'out');
          expect(neighbors).toEqual(['b']);

          await g.deleteNode('b');

          // Rust index should treat it as tombstoned
          neighbors = g.native.traverse(['a'], 'LINK', 'out');
          expect(neighbors).toEqual([]);

          // Check DB soft delete
          const rows = await g.db.query("SELECT * FROM nodes WHERE id = 'b' AND valid_to IS NOT NULL");
          expect(rows.length).toBe(1);
        });
      });
    patchStrategy: replace
  - type: write
    path: test/integration/persistence.test.ts
    content: |-
      import { describe, test, expect, afterEach } from 'bun:test';
      import { createGraph, cleanupGraph } from '../utils/helpers';
      import { QuackGraph } from '../../packages/quack-graph/src/index';

      describe('Integration: Persistence & Hydration', () => {
        // Keep track of paths to clean up
        const paths: string[] = [];

        afterEach(async () => {
          for (const p of paths) {
            await cleanupGraph(p);
          }
          paths.length = 0; // Clear
        });

        test('should hydrate Rust topology from Disk on startup', async () => {
          // 1. Setup Graph A (Disk)
          const setup = await createGraph('disk', 'persist-hydrate');
          const g1 = setup.graph;
          const path = setup.path;
          paths.push(path);

          // 2. Add Data to Graph A
          await g1.addNode('root', ['Root']);
          await g1.addNode('child1', ['Leaf']);
          await g1.addNode('child2', ['Leaf']);
          await g1.addEdge('root', 'child1', 'PARENT_OF');
          await g1.addEdge('root', 'child2', 'PARENT_OF');

          expect(g1.native.nodeCount).toBe(3);
          expect(g1.native.edgeCount).toBe(2);

          // 3. Initialize Graph B on the same file (Simulates Restart)
          const g2 = new QuackGraph(path);
          await g2.init(); // Triggers hydrate() from Arrow IPC

          // 4. Verify Graph B State
          expect(g2.native.nodeCount).toBe(3);
          expect(g2.native.edgeCount).toBe(2);

          const children = g2.native.traverse(['root'], 'PARENT_OF', 'out');
          expect(children.length).toBe(2);
          expect(children.sort()).toEqual(['child1', 'child2']);
        });

        test('should respect soft deletes during hydration', async () => {
          const setup = await createGraph('disk', 'persist-soft-del');
          const g1 = setup.graph;
          paths.push(setup.path);

          await g1.addNode('a', ['A']);
          await g1.addNode('b', ['B']);
          await g1.addEdge('a', 'b', 'KNOWS');

          // Soft Delete
          await g1.deleteEdge('a', 'b', 'KNOWS');
          
          // Verify immediate effect in Memory
          expect(g1.native.traverse(['a'], 'KNOWS', 'out')).toEqual([]);

          // Restart / Hydrate
          const g2 = new QuackGraph(setup.path);
          await g2.init();

          // Verify Deleted Edge is NOT hydrated
          // The query `SELECT ... WHERE valid_to IS NULL` should exclude it
          expect(g2.native.edgeCount).toBe(0);
          const neighbors = g2.native.traverse(['a'], 'KNOWS', 'out');
          expect(neighbors).toEqual([]);
        });

        test('Snapshot: should save and load binary topology', async () => {
          const setup = await createGraph('disk', 'persist-snapshot');
          const g1 = setup.graph;
          paths.push(setup.path);
          const snapshotPath = `${setup.path}.bin`;
          paths.push(snapshotPath); // Cleanup this too

          // Populate
          await g1.addNode('x', ['X']);
          await g1.addNode('y', ['Y']);
          await g1.addEdge('x', 'y', 'LINK');

          // Save Snapshot
          g1.optimize.saveTopologySnapshot(snapshotPath);

          // Load New Graph using Snapshot (skipping DB hydration)
          const g2 = new QuackGraph(setup.path, { topologySnapshot: snapshotPath });
          await g2.init();

          expect(g2.native.nodeCount).toBe(2);
          expect(g2.native.edgeCount).toBe(1);
          expect(g2.native.traverse(['x'], 'LINK', 'out')).toEqual(['y']);
        });

        test('Special Characters: should handle emojis and spaces in IDs', async () => {
          const setup = await createGraph('disk', 'persist-special');
          const g1 = setup.graph;
          paths.push(setup.path);

          const id1 = 'User A (Admin)';
          const id2 = 'User B ðŸ¦†';

          await g1.addNode(id1, ['User']);
          await g1.addNode(id2, ['User']);
          await g1.addEdge(id1, id2, 'EMOJI_LINK ðŸ”—');

          // Restart
          const g2 = new QuackGraph(setup.path);
          await g2.init();

          const result = g2.native.traverse([id1], 'EMOJI_LINK ðŸ”—', 'out');
          expect(result).toEqual([id2]);
          
          // Reverse
          const reverse = g2.native.traverse([id2], 'EMOJI_LINK ðŸ”—', 'in');
          expect(reverse).toEqual([id1]);
        });
      });
    patchStrategy: replace
  - type: write
    path: test/integration/concurrency.test.ts
    content: |-
      import { describe, test, expect, afterEach } from 'bun:test';
      import { createGraph, cleanupGraph } from '../utils/helpers';

      describe('Integration: Concurrency', () => {
        let path: string;

        afterEach(async () => {
          if (path) await cleanupGraph(path);
        });

        test('should handle concurrent node additions without data loss', async () => {
          const setup = await createGraph('disk', 'int-concurrency');
          const g = setup.graph;
          path = setup.path;

          const count = 100;
          const promises = [];

          // Fire 100 writes "simultaneously"
          for (let i = 0; i < count; i++) {
            promises.push(g.addNode(`node:${i}`, ['Node'], { index: i }));
          }

          await Promise.all(promises);

          expect(g.native.nodeCount).toBe(count);
          
          // Check DB persistence
          const rows = await g.db.query('SELECT count(*) as c FROM nodes WHERE valid_to IS NULL');
          const c = Number(rows[0].c); 
          expect(c).toBe(count);
        });

        test('should handle concurrent edge additions between same nodes', async () => {
          // Tests locking mechanism on adjacency list (if any) or vector resizing safety
          const setup = await createGraph('disk', 'int-concurrency-edges');
          const g = setup.graph;
          path = setup.path;

          await g.addNode('A', ['Node']);
          await g.addNode('B', ['Node']);

          const count = 50;
          const promises = [];

          // Add 50 edges "simultaneously" of DIFFERENT types to avoid idempotency masking the test
          for (let i = 0; i < count; i++) {
            promises.push(g.addEdge('A', 'B', `LINK_${i}`));
          }

          await Promise.all(promises);

          expect(g.native.edgeCount).toBe(count);

          // Verify traversal finds them all
          // Checking one specific link
          const neighbors = g.native.traverse(['A'], 'LINK_42', 'out');
          expect(neighbors).toEqual(['B']);
        });
      });
    patchStrategy: replace
  - type: write
    path: test/integration/lifecycle.test.ts
    content: >-
      // Consolidating lifecycle tests into persistence.test.ts to avoid
      redundancy.

      // This file can be deleted.
    patchStrategy: replace
snapshot:
  test/utils/helpers.ts: >-
    import { unlink } from 'node:fs/promises';

    import { join } from 'node:path';

    import { tmpdir } from 'node:os';

    import { QuackGraph } from '../../packages/quack-graph/src/index';


    export const getTempPath = (prefix = 'quack-test') => {
      const uuid = crypto.randomUUID();
      return join(tmpdir(), `${prefix}-${uuid}.duckdb`);
    };


    export const createGraph = async (mode: 'memory' | 'disk' = 'memory',
    dbName?: string) => {
      const path = mode === 'memory' ? ':memory:' : getTempPath(dbName);
      const graph = new QuackGraph(path);
      await graph.init();
      return { graph, path };
    };


    export const cleanupGraph = async (path: string) => {
      if (path === ':memory:') return;
      try {
        await unlink(path);
        // DuckDB creates a WAL file typically (.wal), try to remove it too just in case
        await unlink(`${path}.wal`).catch(() => {});
        await unlink(`${path}.tmp`).catch(() => {});
      } catch (_e) {
        // Ignore errors if file doesn't exist
      }
    };


    /**
     * Wait for a short duration. Useful if we need to ensure timestamps differ slightly
     * (though QuackGraph uses microsecond precision usually, node might be ms).
     */
    export const sleep = (ms: number) => new Promise((resolve) =>
    setTimeout(resolve, ms));


    /**
     * Seeds a basic graph with a few nodes and edges for testing traversals.
     * A -> B -> C
     *      |
     *      v
     *      D
     */
    export const seedBasicGraph = async (g: QuackGraph) => {
      await g.addNode('a', ['Node']);
      await g.addNode('b', ['Node']);
      await g.addNode('c', ['Node']);
      await g.addNode('d', ['Node']);
      await g.addEdge('a', 'b', 'NEXT');
      await g.addEdge('b', 'c', 'NEXT');
      await g.addEdge('b', 'd', 'NEXT');
    };
  test/integration/persistence.test.ts: |-
    import { describe, test, expect, afterEach } from 'bun:test';
    import { createGraph, cleanupGraph } from '../utils/helpers';
    import { QuackGraph } from '../../packages/quack-graph/src/index';

    describe('Integration: Persistence & Hydration', () => {
      // Keep track of paths to clean up
      const paths: string[] = [];

      afterEach(async () => {
        for (const p of paths) {
          await cleanupGraph(p);
        }
        paths.length = 0; // Clear
      });

      test('should hydrate Rust topology from Disk on startup', async () => {
        // 1. Setup Graph A (Disk)
        const setup = await createGraph('disk', 'persist-hydrate');
        const g1 = setup.graph;
        const path = setup.path;
        paths.push(path);

        // 2. Add Data to Graph A
        await g1.addNode('root', ['Root']);
        await g1.addNode('child1', ['Leaf']);
        await g1.addNode('child2', ['Leaf']);
        await g1.addEdge('root', 'child1', 'PARENT_OF');
        await g1.addEdge('root', 'child2', 'PARENT_OF');

        expect(g1.native.nodeCount).toBe(3);
        expect(g1.native.edgeCount).toBe(2);

        // 3. Initialize Graph B on the same file (Simulates Restart)
        const g2 = new QuackGraph(path);
        await g2.init(); // Triggers hydrate() from Arrow IPC

        // 4. Verify Graph B State
        expect(g2.native.nodeCount).toBe(3);
        expect(g2.native.edgeCount).toBe(2);

        const children = g2.native.traverse(['root'], 'PARENT_OF', 'out');
        expect(children.length).toBe(2);
        expect(children.sort()).toEqual(['child1', 'child2']);
      });

      test('should respect soft deletes during hydration', async () => {
        const setup = await createGraph('disk', 'persist-soft-del');
        const g1 = setup.graph;
        paths.push(setup.path);

        await g1.addNode('a', ['A']);
        await g1.addNode('b', ['B']);
        await g1.addEdge('a', 'b', 'KNOWS');

        // Soft Delete
        await g1.deleteEdge('a', 'b', 'KNOWS');
        
        // Verify immediate effect in Memory
        expect(g1.native.traverse(['a'], 'KNOWS', 'out')).toEqual([]);

        // Restart / Hydrate
        const g2 = new QuackGraph(setup.path);
        await g2.init();

        // Verify Deleted Edge is NOT hydrated
        // The query `SELECT ... WHERE valid_to IS NULL` should exclude it
        expect(g2.native.edgeCount).toBe(0);
        const neighbors = g2.native.traverse(['a'], 'KNOWS', 'out');
        expect(neighbors).toEqual([]);
      });

      test('Snapshot: should save and load binary topology', async () => {
        const setup = await createGraph('disk', 'persist-snapshot');
        const g1 = setup.graph;
        paths.push(setup.path);
        const snapshotPath = `${setup.path}.bin`;
        paths.push(snapshotPath); // Cleanup this too

        // Populate
        await g1.addNode('x', ['X']);
        await g1.addNode('y', ['Y']);
        await g1.addEdge('x', 'y', 'LINK');

        // Save Snapshot
        g1.optimize.saveTopologySnapshot(snapshotPath);

        // Load New Graph using Snapshot (skipping DB hydration)
        const g2 = new QuackGraph(setup.path, { topologySnapshot: snapshotPath });
        await g2.init();

        expect(g2.native.nodeCount).toBe(2);
        expect(g2.native.edgeCount).toBe(1);
        expect(g2.native.traverse(['x'], 'LINK', 'out')).toEqual(['y']);
      });

      test('Special Characters: should handle emojis and spaces in IDs', async () => {
        const setup = await createGraph('disk', 'persist-special');
        const g1 = setup.graph;
        paths.push(setup.path);

        const id1 = 'User A (Admin)';
        const id2 = 'User B ðŸ¦†';

        await g1.addNode(id1, ['User']);
        await g1.addNode(id2, ['User']);
        await g1.addEdge(id1, id2, 'EMOJI_LINK ðŸ”—');

        // Restart
        const g2 = new QuackGraph(setup.path);
        await g2.init();

        const result = g2.native.traverse([id1], 'EMOJI_LINK ðŸ”—', 'out');
        expect(result).toEqual([id2]);
        
        // Reverse
        const reverse = g2.native.traverse([id2], 'EMOJI_LINK ðŸ”—', 'in');
        expect(reverse).toEqual([id1]);
      });
    });
  test/integration/concurrency.test.ts: |-
    import { describe, test, expect, afterEach } from 'bun:test';
    import { createGraph, cleanupGraph } from '../utils/helpers';

    describe('Integration: Concurrency', () => {
      let path: string;

      afterEach(async () => {
        if (path) await cleanupGraph(path);
      });

      test('should handle concurrent node additions without data loss', async () => {
        const setup = await createGraph('disk', 'int-concurrency');
        const g = setup.graph;
        path = setup.path;

        const count = 100;
        const promises = [];

        // Fire 100 writes "simultaneously"
        for (let i = 0; i < count; i++) {
          promises.push(g.addNode(`node:${i}`, ['Node'], { index: i }));
        }

        await Promise.all(promises);

        expect(g.native.nodeCount).toBe(count);
        
        // Check DB persistence
        const rows = await g.db.query('SELECT count(*) as c FROM nodes WHERE valid_to IS NULL');
        const c = Number(rows[0].c); 
        expect(c).toBe(count);
      });

      test('should handle concurrent edge additions between same nodes', async () => {
        // Tests locking mechanism on adjacency list (if any) or vector resizing safety
        const setup = await createGraph('disk', 'int-concurrency-edges');
        const g = setup.graph;
        path = setup.path;

        await g.addNode('A', ['Node']);
        await g.addNode('B', ['Node']);

        const count = 50;
        const promises = [];

        // Add 50 edges "simultaneously" of DIFFERENT types to avoid idempotency masking the test
        for (let i = 0; i < count; i++) {
          promises.push(g.addEdge('A', 'B', `LINK_${i}`));
        }

        await Promise.all(promises);

        expect(g.native.edgeCount).toBe(count);

        // Verify traversal finds them all
        // Checking one specific link
        const neighbors = g.native.traverse(['A'], 'LINK_42', 'out');
        expect(neighbors).toEqual(['B']);
      });
    });
  test/unit/graph.test.ts: |-
    import { describe, test, expect, beforeEach, afterEach } from 'bun:test';
    import { createGraph, cleanupGraph } from '../utils/helpers';
    import type { QuackGraph } from '../../packages/quack-graph/src/index';

    describe('Unit: QuackGraph Core', () => {
      let g: QuackGraph;
      let path: string;

      beforeEach(async () => {
        const setup = await createGraph('memory');
        g = setup.graph;
        path = setup.path;
      });

      afterEach(async () => {
        await cleanupGraph(path);
      });

      test('should initialize with zero nodes', () => {
        expect(g.native.nodeCount).toBe(0);
        expect(g.native.edgeCount).toBe(0);
      });

      test('should add nodes and increment count', async () => {
        await g.addNode('u:1', ['User'], { name: 'Alice' });
        await g.addNode('u:2', ['User'], { name: 'Bob' });
        
        // Check Rust Index
        expect(g.native.nodeCount).toBe(2);
        
        // Check DuckDB Storage
        const rows = await g.db.query('SELECT * FROM nodes');
        expect(rows.length).toBe(2);
        expect(rows.find(r => r.id === 'u:1').properties).toContain('Alice');
      });

      test('should add edges and support traversal', async () => {
        await g.addNode('a', ['Node']);
        await g.addNode('b', ['Node']);
        await g.addEdge('a', 'b', 'LINK');

        expect(g.native.edgeCount).toBe(1);

        // Simple manual traversal check using native directly
        const neighbors = g.native.traverse(['a'], 'LINK', 'out');
        expect(neighbors).toEqual(['b']);
      });

      test('should be idempotent when adding same edge', async () => {
        await g.addNode('a', ['Node']);
        await g.addNode('b', ['Node']);
        
        await g.addEdge('a', 'b', 'LINK');
        await g.addEdge('a', 'b', 'LINK'); // Duplicate

        expect(g.native.edgeCount).toBe(1);
        const neighbors = g.native.traverse(['a'], 'LINK', 'out');
        expect(neighbors).toEqual(['b']);
      });

      test('should soft delete nodes and stop traversal', async () => {
        await g.addNode('a', ['Node']);
        await g.addNode('b', ['Node']);
        await g.addEdge('a', 'b', 'LINK');

        let neighbors = g.native.traverse(['a'], 'LINK', 'out');
        expect(neighbors).toEqual(['b']);

        await g.deleteNode('b');

        // Rust index should treat it as tombstoned
        neighbors = g.native.traverse(['a'], 'LINK', 'out');
        expect(neighbors).toEqual([]);

        // Check DB soft delete
        const rows = await g.db.query("SELECT * FROM nodes WHERE id = 'b' AND valid_to IS NOT NULL");
        expect(rows.length).toBe(1);
      });
    });
  test/integration/lifecycle.test.ts: |-
    import { describe, test, expect } from 'bun:test';
    import { createGraph, cleanupGraph } from '../utils/helpers';
    import { QuackGraph } from '../../packages/quack-graph/src/index';

    describe('Integration: Persistence & Hydration', () => {
      test('should hydrate Rust topology from Disk on startup', async () => {
        // 1. Setup Graph A (Disk)
        const { graph: g1, path } = await createGraph('disk');

        // 2. Add Data to Graph A
        await g1.addNode('root', ['Root']);
        await g1.addNode('child1', ['Leaf']);
        await g1.addNode('child2', ['Leaf']);
        await g1.addEdge('root', 'child1', 'PARENT_OF');
        await g1.addEdge('root', 'child2', 'PARENT_OF');

        expect(g1.native.nodeCount).toBe(3);
        expect(g1.native.edgeCount).toBe(2);

        // 3. Initialize Graph B on the same file (Simulates Restart)
        // Note: In same process, DuckDB handles concurrent access to same file fine
        const g2 = new QuackGraph(path);
        await g2.init(); // This triggers hydrate()

        // 4. Verify Graph B State
        expect(g2.native.nodeCount).toBe(3);
        expect(g2.native.edgeCount).toBe(2);

        const children = g2.native.traverse(['root'], 'PARENT_OF', 'out');
        expect(children.length).toBe(2);
        expect(children).toContain('child1');
        expect(children).toContain('child2');

        await cleanupGraph(path);
      });

      test('should respect soft deletes during hydration', async () => {
        // 1. Setup & Add Data
        const { graph: g1, path } = await createGraph('disk');
        await g1.addNode('a', ['A']);
        await g1.addNode('b', ['B']);
        await g1.addEdge('a', 'b', 'KNOWS');

        // 2. Soft Delete
        await g1.deleteEdge('a', 'b', 'KNOWS');
        
        // Verify immediate effect
        expect(g1.native.traverse(['a'], 'KNOWS', 'out')).toEqual([]);

        // 3. Restart / Hydrate
        const g2 = new QuackGraph(path);
        await g2.init();

        // 4. Verify Deleted Edge is NOT hydrated
        // The query `SELECT ... WHERE valid_to IS NULL` should exclude it
        expect(g2.native.edgeCount).toBe(0);
        const neighbors = g2.native.traverse(['a'], 'KNOWS', 'out');
        expect(neighbors).toEqual([]);

        await cleanupGraph(path);
      });
    });
approved: true
linesAdded: 6
linesRemoved: 64
linesDifference: 70
gitCommittedAt: '2025-12-02T12:44:32.423Z'
status: committed
id: 38
