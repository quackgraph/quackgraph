uuid: 4f13a0e6-9917-48f8-b3d6-444a7f5195b0
projectId: quackgraph
createdAt: '2025-12-02T14:16:31.804Z'
gitCommitMsg: >-
  feat(query): Add server-side analytics builder

  - Adds `groupBy`, `orderBy`, `limit`, and `offset` methods to the
  `QueryBuilder`. - Enhances the `select` method to accept raw SQL projection
  strings (e.g., 'COUNT(*) as c'). - The builder now constructs SQL queries with
  these clauses, pushing aggregation and sorting logic down to DuckDB for
  significantly improved performance.
promptSummary: >-
  The user requested only Part 2 of the previous plan. This involved updating
  the TypeScript QueryBuilder to support server-side analytics, including
  methods for GROUP BY, ORDER BY, LIMIT, and OFFSET, and allowing raw SQL
  projections.
reasoning:
  - >-
    Of course. Here is the execution of Part 2 only, which implements the
    TypeScript-based Analytics Builder.
  - '### Part 2: TypeScript Analytics Builder'
  - >-
    I will update the `QueryBuilder` in `packages/quack-graph/src/query.ts` to
    support server-side aggregations. This involves adding methods like
    `groupBy`, `orderBy`, and `limit`, and enhancing the `select` method to
    construct and execute SQL queries that push this analytical logic down into
    DuckDB, which is significantly more performant than pulling large datasets
    into JavaScript.
operations:
  - type: write
    path: packages/quack-graph/src/query.ts
    content: >
      --- packages/quack-graph/src/query.ts

      +++ packages/quack-graph/src/query.ts

      @@ -23,6 +23,13 @@
         // biome-ignore lint/suspicious/noExplicitAny: Generic filter criteria
         private terminalFilters: Record<string, any> = {};
       
      +  private aggState = {

      +    groupBy: [] as string[],

      +    orderBy: [] as { field: string; dir: 'ASC' | 'DESC' }[],

      +    limit: undefined as number | undefined,

      +    offset: undefined as number | undefined,

      +  };

      +
         constructor(graph: QuackGraph, labels: string[]) {
           this.graph = graph;
           this.startLabels = labels;
      @@ -85,6 +92,26 @@
           return this;
         }
       
      +  groupBy(field: string): this {

      +    this.aggState.groupBy.push(field);

      +    return this;

      +  }

      +

      +  orderBy(field: string, dir: 'ASC' | 'DESC' = 'ASC'): this {

      +    this.aggState.orderBy.push({ field, dir });

      +    return this;

      +  }

      +

      +  limit(n: number): this {

      +    this.aggState.limit = n;

      +    return this;

      +  }

      +

      +  offset(n: number): this {

      +    this.aggState.offset = n;

      +    return this;

      +  }

      +
         /**
          * Filter the nodes at the end of the traversal by label.
          */
      @@ -109,8 +136,13 @@
           return `${prefix}valid_to IS NULL`;
         }
       
      +  /**

      +   * Executes the query.

      +   * @param projection Optional SQL projection string (e.g., 'count(*),
      avg(properties->>age)') or a JS mapper function.

      +   */
         // biome-ignore lint/suspicious/noExplicitAny: Generic result mapper
      -  async select<T = any>(mapper?: (node: any) => T): Promise<T[]> {

      +  async select<T = any>(projection?: string | ((node: any) => T)):
      Promise<T[]> {

      +    const isRawSql = typeof projection === 'string';

      +    const mapper = typeof projection === 'function' ? projection :
      undefined;

      +
           // --- Step 1: DuckDB Filter (Bottom Bun) ---
           // Objective: Get a list of "Active" Node IDs to feed into the graph.
       
      @@ -216,10 +248,34 @@
             }
           }
       
      -    const finalSql = `SELECT * FROM nodes WHERE ${finalConditions.join('
      AND ')}`;

      +    // 3.d Aggregation / Grouping / Ordering

      +    let selectClause = 'SELECT *';

      +    if (isRawSql) {

      +      selectClause = `SELECT ${projection}`;

      +    }

      +

      +    let suffix = '';

      +    if (this.aggState.groupBy.length > 0) {

      +      suffix += ` GROUP BY ${this.aggState.groupBy.join(', ')}`;

      +    }

      +    

      +    if (this.aggState.orderBy.length > 0) {

      +      const orders = this.aggState.orderBy.map(o => `${o.field}
      ${o.dir}`).join(', ');

      +      suffix += ` ORDER BY ${orders}`;

      +    }

      +

      +    if (this.aggState.limit !== undefined) {

      +      suffix += ` LIMIT ${this.aggState.limit}`;

      +    }

      +    if (this.aggState.offset !== undefined) {

      +      suffix += ` OFFSET ${this.aggState.offset}`;

      +    }

      +

      +    const finalSql = `${selectClause} FROM nodes WHERE
      ${finalConditions.join(' AND ')} ${suffix}`;
           const results = await this.graph.db.query(finalSql, finalParams);
       
           return results.map(r => {
      +      if (isRawSql) return r;

      +
             let props = r.properties;
             if (typeof props === 'string') {
               try { props = JSON.parse(props); } catch {}
    patchStrategy: standard-diff
snapshot:
  packages/quack-graph/src/query.ts: |-
    import type { QuackGraph } from './graph';

    type TraversalStep = {
      type: 'out' | 'in' | 'recursive';
      edge: string;
      direction?: 'out' | 'in';
      bounds?: { min: number; max: number };
    };

    export class QueryBuilder {
      private graph: QuackGraph;
      private startLabels: string[];
      private endLabels: string[] = [];

      // Bottom Bun Filters (Initial selection)
      // biome-ignore lint/suspicious/noExplicitAny: Generic filter criteria
      private initialFilters: Record<string, any> = {};
      private vectorSearch: { vector: number[]; limit: number } | null = null;

      // The Meat (Traversal)
      private traversals: TraversalStep[] = [];

      // Top Bun Filters (Final selection)
      // biome-ignore lint/suspicious/noExplicitAny: Generic filter criteria
      private terminalFilters: Record<string, any> = {};

      constructor(graph: QuackGraph, labels: string[]) {
        this.graph = graph;
        this.startLabels = labels;
      }

      /**
       * Traverses the graph recursively (BFS) with depth bounds.
       * Useful for variable length paths like `(a)-[:KNOWS*1..5]->(b)`.
       * @param edgeType The edge label to follow.
       * @param options min/max depth (default: 1..5).
       * @param direction 'out' (default) or 'in'.
       */
      recursive(edgeType: string, options: { min?: number; max?: number } = {}, direction: 'out' | 'in' = 'out'): this {
        this.traversals.push({
          type: 'recursive',
          edge: edgeType,
          direction,
          bounds: {
            min: options.min ?? 1,
            max: options.max ?? 5,
          }
        });
        return this;
      }

      /**
       * Filter nodes by properties.
       * If called before traversal, applies to Start Nodes.
       * If called after traversal, applies to End Nodes.
       */
      // biome-ignore lint/suspicious/noExplicitAny: Generic filter criteria
      where(criteria: Record<string, any>): this {
        if (this.traversals.length === 0) {
          this.initialFilters = { ...this.initialFilters, ...criteria };
        } else {
          this.terminalFilters = { ...this.terminalFilters, ...criteria };
        }
        return this;
      }

      /**
       * Perform a Vector Similarity Search (HNSW).
       * This effectively sorts the start nodes by distance to the query vector.
       */
      nearText(vector: number[], options: { limit?: number } = {}): this {
        this.vectorSearch = { 
          vector, 
          limit: options.limit || 10 
        };
        return this;
      }

      out(edgeType: string): this {
        this.traversals.push({ type: 'out', edge: edgeType });
        return this;
      }

      in(edgeType: string): this {
        this.traversals.push({ type: 'in', edge: edgeType });
        return this;
      }

      /**
       * Filter the nodes at the end of the traversal by label.
       */
      node(labels: string[]): this {
        this.endLabels = labels;
        return this;
      }

      /**
       * Helper to construct the temporal validity clause
       */
      private getTemporalClause(tableAlias: string = ''): string {
        const prefix = tableAlias ? `${tableAlias}.` : '';
        if (this.graph.context.asOf) {
          // Time Travel: valid_from <= T AND (valid_to > T OR valid_to IS NULL)
          // Interpolate strict ISO string
          const iso = this.graph.context.asOf.toISOString();
          // DuckDB TIMESTAMP comparison works with ISO strings
          return `(${prefix}valid_from <= '${iso}' AND (${prefix}valid_to > '${iso}' OR ${prefix}valid_to IS NULL))`;
        }
        // Default: Current valid records (valid_to is NULL)
        return `${prefix}valid_to IS NULL`;
      }

      // biome-ignore lint/suspicious/noExplicitAny: Generic result mapper
      async select<T = any>(mapper?: (node: any) => T): Promise<T[]> {
        // --- Step 1: DuckDB Filter (Bottom Bun) ---
        // Objective: Get a list of "Active" Node IDs to feed into the graph.

        let query = `SELECT id FROM nodes`;
        // biome-ignore lint/suspicious/noExplicitAny: SQL parameters
        const params: any[] = [];
        const conditions: string[] = [];

        // 1.a Temporal Filter
        conditions.push(this.getTemporalClause());

        // 1.b Label Filter
        if (this.startLabels.length > 0) {
          // Check if ANY of the labels match. For V1 we check the first one or intersection.
          conditions.push(`list_contains(labels, ?)`);
          params.push(this.startLabels[0]);
        }

        // 1.c Property Filter
        for (const [key, value] of Object.entries(this.initialFilters)) {
          if (key === 'id') {
            conditions.push(`id = ?`);
            params.push(value);
          } else {
            conditions.push(`json_extract(properties, '$.${key}') = ?::JSON`);
            params.push(JSON.stringify(value));
          }
        }

        // 1.d Vector Search (Order By Distance)
        let orderBy = '';
        let limit = '';
        if (this.vectorSearch) {
          // Requires: array_distance(embedding, [1,2,3])
          // DuckDB VSS extension syntax
          const vectorStr = `[${this.vectorSearch.vector.join(',')}]`; // Inline vector for V1
          orderBy = `ORDER BY array_distance(embedding, ${vectorStr}::FLOAT[${this.vectorSearch.vector.length}])`;
          limit = `LIMIT ${this.vectorSearch.limit}`;
        }

        if (conditions.length > 0) {
          query += ` WHERE ${conditions.join(' AND ')}`;
        }

        query += ` ${orderBy} ${limit}`;

        const startRows = await this.graph.db.query(query, params);
        let currentIds: string[] = startRows.map(row => row.id);

        if (currentIds.length === 0) return [];

        // --- Step 2: Rust Traversal (The Meat) ---
        // Note: Rust Graph Index is currently "Latest Topology Only". 
        // Time Travel on topology requires checking edge validity during traversal (V2).
        // For V1, we accept that traversal is instant/current, but properties are historical.

        for (const step of this.traversals) {
          if (currentIds.length === 0) break;
          
          if (step.type === 'recursive') {
            currentIds = this.graph.native.traverseRecursive(
              currentIds,
              step.edge,
              step.direction || 'out',
              step.bounds?.min,
              step.bounds?.max
            );
          } else {
            // step.type is 'out' | 'in'
            currentIds = this.graph.native.traverse(currentIds, step.edge, step.type as 'out' | 'in');
          }
        }

        // Optimization: If traversal resulted in no nodes, stop early.
        if (currentIds.length === 0) return [];

        // --- Step 3: DuckDB Hydration (Top Bun) ---
        // Objective: Fetch full properties for the resulting IDs, applying terminal filters.

        const finalConditions: string[] = [];
        // biome-ignore lint/suspicious/noExplicitAny: SQL parameters
        const finalParams: any[] = [];

        // 3.0 Label Filter (for End Nodes)
        if (this.endLabels.length > 0) {
          finalConditions.push(`list_contains(labels, ?)`);
          finalParams.push(this.endLabels[0]);
        }

        // 3.a IDs match
        // We can't use parameters for IN clause effectively with dynamic length in all drivers.
        // Constructing placeholders.
        const placeholders = currentIds.map(() => '?').join(',');
        finalConditions.push(`id IN (${placeholders})`);
        finalParams.push(...currentIds);

        // 3.b Temporal Validity
        finalConditions.push(this.getTemporalClause());

        // 3.c Terminal Property Filters
        for (const [key, value] of Object.entries(this.terminalFilters)) {
          if (key === 'id') {
            finalConditions.push(`id = ?`);
            finalParams.push(value);
          } else {
            finalConditions.push(`json_extract(properties, '$.${key}') = ?::JSON`);
            finalParams.push(JSON.stringify(value));
          }
        }

        const finalSql = `SELECT * FROM nodes WHERE ${finalConditions.join(' AND ')}`;
        const results = await this.graph.db.query(finalSql, finalParams);

        return results.map(r => {
          let props = r.properties;
          if (typeof props === 'string') {
            try { props = JSON.parse(props); } catch {}
          }
          const node = {
            id: r.id,
            labels: r.labels,
            ...props
          };
          return mapper ? mapper(node) : node;
        });
      }
    }
approved: true
linesAdded: 61
linesRemoved: 2
linesDifference: 63
gitCommittedAt: '2025-12-02T14:20:12.498Z'
status: committed
id: 48
