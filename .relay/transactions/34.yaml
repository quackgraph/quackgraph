uuid: 4c3e3871-3375-4c07-88af-8393521b4a42
projectId: quackgraph
createdAt: '2025-12-02T12:22:08.326Z'
gitCommitMsg: >-
  feat(query): add incoming traversal support and e2e domain tests

  - Adds `.in(edge)` to QueryBuilder for reverse traversals. - Adds
  test/e2e/fraud.test.ts: Multi-hop fraud ring detection. - Adds
  test/e2e/recommendation.test.ts: Collaborative filtering scenario.
promptSummary: >-
  Executed Part 5 (E2E Domain Scenarios). Added `.in()` method to QueryBuilder.
  Created fraud detection (graph analysis) and recommendation (collaborative
  filtering) E2E tests using bidirectional traversals.
reasoning:
  - 'Step-by-Step Reasoning:'
  - >-
    1.  **Analyze Dependencies**: The E2E tests for "Fraud Detection" and
    "Recommendations" heavily rely on bidirectional graph traversals (e.g.,
    finding other users who used the *same* device).
  - >-
    2.  **Identify Gap**: Reviewing `packages/quack-graph/src/query.ts` reveals
    that while `TraversalStep` supports `'in'`, the `QueryBuilder` class is
    missing the public `.in(edgeType)` method.
  - >-
    3.  **Remediation**: Before writing the tests, I must patch `QueryBuilder`
    to expose the incoming traversal capability.
  - '4.  **Draft Fraud Test**:'
  - >-
    *   Setup a "Ring": User A and User B share Device 1. User B and User C
    share Credit Card 1.
  - '*   Goal: Start at User A, find User C via the shared path.'
  - >-
    *   Path: `User A` -> `HAS_DEVICE` -> `Device 1` <- `HAS_DEVICE` (reverse)
    -> `User B` -> `HAS_CARD` -> `Card 1` <- `HAS_CARD` (reverse) -> `User C`.
  - '5.  **Draft Recommendation Test**:'
  - '*   Setup: Alice bought {Phone, Case}. Bob bought {Phone}.'
  - '*   Goal: Recommend "Case" to Bob.'
  - >-
    *   Logic: Bob -> `BOUGHT` -> Phone <- `BOUGHT` (reverse) -> Alice ->
    `BOUGHT` -> Case.
  - '6.  **Execute**: Apply patch, then create both test files.'
operations:
  - type: write
    path: packages/quack-graph/src/query.ts
    content: |
      --- packages/quack-graph/src/query.ts
      +++ packages/quack-graph/src/query.ts
      @@ -60,6 +60,11 @@
         }
       
      +  in(edgeType: string): this {
      +    this.traversals.push({ type: 'in', edge: edgeType });
      +    return this;
      +  }
      +
         /**
          * Filter the nodes at the end of the traversal by label.
          */
    patchStrategy: standard-diff
  - type: write
    path: test/e2e/fraud.test.ts
    content: |-
      import { describe, test, expect, afterEach } from 'bun:test';
      import { createGraph, cleanupGraph } from '../utils/helpers';
      import type { QuackGraph } from '../../packages/quack-graph/src/index';

      describe('E2E: Fraud Detection (Graph Analysis)', () => {
        let g: QuackGraph;
        let path: string;

        afterEach(async () => {
          if (path) await cleanupGraph(path);
        });

        test('should detect indirect links between users via shared resources', async () => {
          const setup = await createGraph('disk', 'e2e-fraud');
          g = setup.graph;
          path = setup.path;

          // 1. Seed Data: A Fraud Ring
          // Bad Actor 1 (A) shares a Device with (B).
          // (B) shares a Credit Card with Bad Actor 2 (C).
          // Link: A -> Device -> B -> Card -> C

          // Nodes
          await g.addNode('user:A', ['User'], { riskScore: 90 });
          await g.addNode('user:B', ['User'], { riskScore: 10 }); // Looks innocent
          await g.addNode('user:C', ['User'], { riskScore: 95 });
          
          await g.addNode('device:D1', ['Device'], { os: 'Android' });
          await g.addNode('card:C1', ['CreditCard'], { bin: 4242 });

          // Edges
          await g.addEdge('user:A', 'device:D1', 'USED_DEVICE');
          await g.addEdge('user:B', 'device:D1', 'USED_DEVICE');
          
          await g.addEdge('user:B', 'card:C1', 'USED_CARD');
          await g.addEdge('user:C', 'card:C1', 'USED_CARD');

          // 2. Query: Find all users linked to 'user:A' via any shared device or card
          // Path: Start(A) -> out(Device) -> in(Device) -> out(Card) -> in(Card) -> Result(C)
          // Note: We need to be careful with traversal steps.
          
          // Step 1: Find devices used by A
          // Step 2: Find users who used those devices (getting B)
          // Step 3: Find cards used by those users (getting C1)
          // Step 4: Find users who used those cards (getting C)
          
          const linkedUsers = await g.match(['User'])
            .where({ riskScore: 90 }) // Select A
            .out('USED_DEVICE')       // -> D1
            .in('USED_DEVICE')        // -> A, B
            .out('USED_CARD')         // -> C1 (from B)
            .in('USED_CARD')          // -> B, C
            .node(['User'])           // Filter just in case
            .select(u => u.id);

          // 3. Verify
          // Should contain C. Might contain A and B depending on cycles, which is fine for graph traversal.
          expect(linkedUsers).toContain('user:C');
          expect(linkedUsers).toContain('user:B');
        });

        test('should isolate clean users from the ring', async () => {
          // Re-use graph or create new? 'afterEach' cleans up, so we need setup again if we wanted clean state.
          // Since we destroy in afterEach, we need to setup again.
          // To speed up, we could do this in one test file with one setup, but isolation is requested.
          // For this specific test, we'll create a new isolated graph.
          
          const setup = await createGraph('disk', 'e2e-fraud-clean');
          const g2 = setup.graph;
          // We rely on afterEach to clean this path too if we update the `path` variable correctly 
          // or we can just manually clean this one. 
          // The `path` variable is scoped to describe, so we update it.
          path = setup.path; 

          await g2.addNode('good_user', ['User']);
          await g2.addNode('bad_user', ['User']);
          await g2.addNode('device:1', ['Device']);
          await g2.addNode('device:2', ['Device']); // Different device

          await g2.addEdge('good_user', 'device:1', 'USED');
          await g2.addEdge('bad_user', 'device:2', 'USED');

          const links = await g2.match(['User'])
            .where({ id: 'good_user' })
            .out('USED')
            .in('USED')
            .select(u => u.id);

          // Should only find themselves (good_user -> device:1 -> good_user)
          expect(links.length).toBe(1);
          expect(links[0]).toBe('good_user');
          expect(links).not.toContain('bad_user');
        });
      });
    patchStrategy: replace
  - type: write
    path: test/e2e/recommendation.test.ts
    content: |-
      import { describe, test, expect, afterEach } from 'bun:test';
      import { createGraph, cleanupGraph } from '../utils/helpers';
      import type { QuackGraph } from '../../packages/quack-graph/src/index';

      describe('E2E: Recommendation Engine (Collaborative Filtering)', () => {
        let g: QuackGraph;
        let path: string;

        afterEach(async () => {
          if (path) await cleanupGraph(path);
        });

        test('should recommend products based on "Users who bought X also bought Y"', async () => {
          const setup = await createGraph('disk', 'e2e-recs');
          g = setup.graph;
          path = setup.path;

          // Data Setup
          // Alice bought: Phone, Headphones, Case
          // Bob bought: Phone
          // Charlie bought: Headphones
          
          // Goal: Recommend "Headphones" and "Case" to Bob because he is similar to Alice (shared Phone).
          
          await g.addNode('Alice', ['User']);
          await g.addNode('Bob', ['User']);
          await g.addNode('Charlie', ['User']);

          await g.addNode('Phone', ['Product'], { price: 800 });
          await g.addNode('Headphones', ['Product'], { price: 200 });
          await g.addNode('Case', ['Product'], { price: 50 });

          // Alice's purchases
          await g.addEdge('Alice', 'Phone', 'BOUGHT');
          await g.addEdge('Alice', 'Headphones', 'BOUGHT');
          await g.addEdge('Alice', 'Case', 'BOUGHT');

          // Bob's purchases
          await g.addEdge('Bob', 'Phone', 'BOUGHT');

          // Charlie's purchases
          await g.addEdge('Charlie', 'Headphones', 'BOUGHT');

          // Query for Bob:
          // 1. What did Bob buy? (Phone)
          // 2. Who else bought that? (Alice)
          // 3. What else did they buy? (Headphones, Case)
          
          const recs = await g.match(['User'])
            .where({ id: 'Bob' })
            .out('BOUGHT')      // -> Phone
            .in('BOUGHT')       // -> Alice, Bob
            .out('BOUGHT')      // -> Phone, Headphones, Case
            .node(['Product'])
            .select(p => p.id);

          // Result should contain products.
          // Note: It will contain 'Phone' because Alice bought it too. 
          // A real engine would filter out already purchased items.
          
          const uniqueRecs = [...new Set(recs)];
          
          expect(uniqueRecs).toContain('Headphones');
          expect(uniqueRecs).toContain('Case');
          expect(uniqueRecs).toContain('Phone');
        });

        test('should filter recommendations by property (e.g. price < 100)', async () => {
          // Re-using the graph state from previous test would be ideal if we didn't teardown.
          // But we teardown. Let's quickly rebuild a smaller version.
          
          const setup = await createGraph('disk', 'e2e-recs-filter');
          g = setup.graph;
          path = setup.path;

          await g.addNode('U1', ['User']);
          await g.addNode('U2', ['User']);
          await g.addNode('Luxury', ['Product'], { price: 1000 });
          await g.addNode('Cheap', ['Product'], { price: 20 });

          // U1 bought both
          await g.addEdge('U1', 'Luxury', 'BOUGHT');
          await g.addEdge('U1', 'Cheap', 'BOUGHT');
          
          // U2 bought Luxury
          await g.addEdge('U2', 'Luxury', 'BOUGHT');

          // Recommend to U2 based on similarity (Luxury), but only Cheap stuff
          const results = await g.match(['User'])
            .where({ id: 'U2' })
            .out('BOUGHT')    // -> Luxury
            .in('BOUGHT')     // -> U1, U2
            .out('BOUGHT')    // -> Luxury, Cheap
            .node(['Product'])
            .where({ price: 20 }) // DuckDB Filter
            .select(p => p.id);

          expect(results).toContain('Cheap');
          expect(results).not.toContain('Luxury');
        });
      });
    patchStrategy: replace
snapshot:
  test/e2e/fraud.test.ts: null
  test/e2e/recommendation.test.ts: null
  packages/quack-graph/src/query.ts: |-
    import type { QuackGraph } from './graph';

    type TraversalStep = {
      type: 'out' | 'in';
      edge: string;
    };

    export class QueryBuilder {
      private graph: QuackGraph;
      private startLabels: string[];
      private endLabels: string[] = [];

      // Bottom Bun Filters (Initial selection)
      // biome-ignore lint/suspicious/noExplicitAny: Generic filter criteria
      private initialFilters: Record<string, any> = {};
      private vectorSearch: { vector: number[]; limit: number } | null = null;

      // The Meat (Traversal)
      private traversals: TraversalStep[] = [];

      // Top Bun Filters (Final selection)
      // biome-ignore lint/suspicious/noExplicitAny: Generic filter criteria
      private terminalFilters: Record<string, any> = {};

      constructor(graph: QuackGraph, labels: string[]) {
        this.graph = graph;
        this.startLabels = labels;
      }

      /**
       * Filter nodes by properties.
       * If called before traversal, applies to Start Nodes.
       * If called after traversal, applies to End Nodes.
       */
      // biome-ignore lint/suspicious/noExplicitAny: Generic filter criteria
      where(criteria: Record<string, any>): this {
        if (this.traversals.length === 0) {
          this.initialFilters = { ...this.initialFilters, ...criteria };
        } else {
          this.terminalFilters = { ...this.terminalFilters, ...criteria };
        }
        return this;
      }

      /**
       * Perform a Vector Similarity Search (HNSW).
       * This effectively sorts the start nodes by distance to the query vector.
       */
      nearText(vector: number[], options: { limit?: number } = {}): this {
        this.vectorSearch = { 
          vector, 
          limit: options.limit || 10 
        };
        return this;
      }

      out(edgeType: string): this {
        this.traversals.push({ type: 'out', edge: edgeType });
        return this;
      }

      /**
       * Filter the nodes at the end of the traversal by label.
       */
      node(labels: string[]): this {
        this.endLabels = labels;
        return this;
      }

      /**
       * Helper to construct the temporal validity clause
       */
      private getTemporalClause(tableAlias: string = ''): string {
        const prefix = tableAlias ? `${tableAlias}.` : '';
        if (this.graph.context.asOf) {
          // Time Travel: valid_from <= T AND (valid_to > T OR valid_to IS NULL)
          // Interpolate strict ISO string
          const iso = this.graph.context.asOf.toISOString();
          // DuckDB TIMESTAMP comparison works with ISO strings
          return `(${prefix}valid_from <= '${iso}' AND (${prefix}valid_to > '${iso}' OR ${prefix}valid_to IS NULL))`;
        }
        // Default: Current valid records (valid_to is NULL)
        return `${prefix}valid_to IS NULL`;
      }

      // biome-ignore lint/suspicious/noExplicitAny: Generic result mapper
      async select<T = any>(mapper?: (node: any) => T): Promise<T[]> {
        // --- Step 1: DuckDB Filter (Bottom Bun) ---
        // Objective: Get a list of "Active" Node IDs to feed into the graph.

        let query = `SELECT id FROM nodes`;
        // biome-ignore lint/suspicious/noExplicitAny: SQL parameters
        const params: any[] = [];
        const conditions: string[] = [];

        // 1.a Temporal Filter
        conditions.push(this.getTemporalClause());

        // 1.b Label Filter
        if (this.startLabels.length > 0) {
          // Check if ANY of the labels match. For V1 we check the first one or intersection.
          conditions.push(`list_contains(labels, ?)`);
          params.push(this.startLabels[0]);
        }

        // 1.c Property Filter
        for (const [key, value] of Object.entries(this.initialFilters)) {
          conditions.push(`json_extract(properties, '$.${key}') = ?::JSON`);
          params.push(JSON.stringify(value));
        }

        // 1.d Vector Search (Order By Distance)
        let orderBy = '';
        let limit = '';
        if (this.vectorSearch) {
          if (!this.graph.capabilities.vss) {
            throw new Error("Vector Search (nearText) requires the 'vss' DuckDB extension, which failed to load.");
          }
          // Requires: array_distance(embedding, [1,2,3])
          // DuckDB VSS extension syntax
          const vectorStr = `[${this.vectorSearch.vector.join(',')}]`; // Inline vector for V1
          orderBy = `ORDER BY array_distance(embedding, ${vectorStr}::FLOAT[${this.vectorSearch.vector.length}])`;
          limit = `LIMIT ${this.vectorSearch.limit}`;
        }

        if (conditions.length > 0) {
          query += ` WHERE ${conditions.join(' AND ')}`;
        }

        query += ` ${orderBy} ${limit}`;

        const startRows = await this.graph.db.query(query, params);
        let currentIds: string[] = startRows.map(row => row.id);

        if (currentIds.length === 0) return [];

        // --- Step 2: Rust Traversal (The Meat) ---
        // Note: Rust Graph Index is currently "Latest Topology Only". 
        // Time Travel on topology requires checking edge validity during traversal (V2).
        // For V1, we accept that traversal is instant/current, but properties are historical.

        for (const step of this.traversals) {
          if (currentIds.length === 0) break;
          // step.type is 'out' | 'in'
          // native.traverse(ids, edgeType, direction)
          currentIds = this.graph.native.traverse(currentIds, step.edge, step.type);
        }

        // Optimization: If traversal resulted in no nodes, stop early.
        if (currentIds.length === 0) return [];

        // --- Step 3: DuckDB Hydration (Top Bun) ---
        // Objective: Fetch full properties for the resulting IDs, applying terminal filters.

        const finalConditions: string[] = [];
        // biome-ignore lint/suspicious/noExplicitAny: SQL parameters
        const finalParams: any[] = [];

        // 3.0 Label Filter (for End Nodes)
        if (this.endLabels.length > 0) {
          finalConditions.push(`list_contains(labels, ?)`);
          finalParams.push(this.endLabels[0]);
        }

        // 3.a IDs match
        // We can't use parameters for IN clause effectively with dynamic length in all drivers.
        // Constructing placeholders.
        const placeholders = currentIds.map(() => '?').join(',');
        finalConditions.push(`id IN (${placeholders})`);
        finalParams.push(...currentIds);

        // 3.b Temporal Validity
        finalConditions.push(this.getTemporalClause());

        // 3.c Terminal Property Filters
        for (const [key, value] of Object.entries(this.terminalFilters)) {
          finalConditions.push(`json_extract(properties, '$.${key}') = ?::JSON`);
          finalParams.push(JSON.stringify(value));
        }

        const finalSql = `SELECT * FROM nodes WHERE ${finalConditions.join(' AND ')}`;
        const results = await this.graph.db.query(finalSql, finalParams);

        return results.map(r => {
          let props = r.properties;
          if (typeof props === 'string') {
            try { props = JSON.parse(props); } catch {}
          }
          const node = {
            id: r.id,
            labels: r.labels,
            ...props
          };
          return mapper ? mapper(node) : node;
        });
      }
    }
approved: true
linesAdded: 200
linesRemoved: 0
linesDifference: 200
gitCommittedAt: null
status: committed
id: 34
